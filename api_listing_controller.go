/*
Api Documentation

Api Documentation

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package atapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// ListingControllerAPIService ListingControllerAPI service
type ListingControllerAPIService service

type ApiFindListingsByAsinPartUsingGETRequest struct {
	ctx context.Context
	ApiService *ListingControllerAPIService
	securityIdentifierPart string
}

func (r ApiFindListingsByAsinPartUsingGETRequest) Execute() (*ListingView, *http.Response, error) {
	return r.ApiService.FindListingsByAsinPartUsingGETExecute(r)
}

/*
FindListingsByAsinPartUsingGET Finds listing by part of their security identifiers

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param securityIdentifierPart Part of security identifier
 @return ApiFindListingsByAsinPartUsingGETRequest
*/
func (a *ListingControllerAPIService) FindListingsByAsinPartUsingGET(ctx context.Context, securityIdentifierPart string) ApiFindListingsByAsinPartUsingGETRequest {
	return ApiFindListingsByAsinPartUsingGETRequest{
		ApiService: a,
		ctx: ctx,
		securityIdentifierPart: securityIdentifierPart,
	}
}

// Execute executes the request
//  @return ListingView
func (a *ListingControllerAPIService) FindListingsByAsinPartUsingGETExecute(r ApiFindListingsByAsinPartUsingGETRequest) (*ListingView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListingView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListingControllerAPIService.FindListingsByAsinPartUsingGET")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/search/listings/{securityIdentifierPart}"
	localVarPath = strings.Replace(localVarPath, "{"+"securityIdentifierPart"+"}", url.PathEscape(parameterValueToString(r.securityIdentifierPart, "securityIdentifierPart")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFindListingsByAsinUsingGETRequest struct {
	ctx context.Context
	ApiService *ListingControllerAPIService
}

func (r ApiFindListingsByAsinUsingGETRequest) Execute() (*ListingView, *http.Response, error) {
	return r.ApiService.FindListingsByAsinUsingGETExecute(r)
}

/*
FindListingsByAsinUsingGET Finds listing by part of their security identifiers

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiFindListingsByAsinUsingGETRequest
*/
func (a *ListingControllerAPIService) FindListingsByAsinUsingGET(ctx context.Context) ApiFindListingsByAsinUsingGETRequest {
	return ApiFindListingsByAsinUsingGETRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListingView
func (a *ListingControllerAPIService) FindListingsByAsinUsingGETExecute(r ApiFindListingsByAsinUsingGETRequest) (*ListingView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListingView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListingControllerAPIService.FindListingsByAsinUsingGET")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/search/listings/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetListingProfileUsingGETRequest struct {
	ctx context.Context
	ApiService *ListingControllerAPIService
	securityIdentifier *string
}

// Security identifier
func (r ApiGetListingProfileUsingGETRequest) SecurityIdentifier(securityIdentifier string) ApiGetListingProfileUsingGETRequest {
	r.securityIdentifier = &securityIdentifier
	return r
}

func (r ApiGetListingProfileUsingGETRequest) Execute() (*ListingProfileView, *http.Response, error) {
	return r.ApiService.GetListingProfileUsingGETExecute(r)
}

/*
GetListingProfileUsingGET Returns listing profile by security identifier

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetListingProfileUsingGETRequest
*/
func (a *ListingControllerAPIService) GetListingProfileUsingGET(ctx context.Context) ApiGetListingProfileUsingGETRequest {
	return ApiGetListingProfileUsingGETRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListingProfileView
func (a *ListingControllerAPIService) GetListingProfileUsingGETExecute(r ApiGetListingProfileUsingGETRequest) (*ListingProfileView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListingProfileView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListingControllerAPIService.GetListingProfileUsingGET")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/listingprofiles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.securityIdentifier != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "securityIdentifier", r.securityIdentifier, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetListingUsingGETRequest struct {
	ctx context.Context
	ApiService *ListingControllerAPIService
	securityIdentifier string
}

func (r ApiGetListingUsingGETRequest) Execute() (*ListingView, *http.Response, error) {
	return r.ApiService.GetListingUsingGETExecute(r)
}

/*
GetListingUsingGET Returns listing

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param securityIdentifier Security Identifier
 @return ApiGetListingUsingGETRequest
*/
func (a *ListingControllerAPIService) GetListingUsingGET(ctx context.Context, securityIdentifier string) ApiGetListingUsingGETRequest {
	return ApiGetListingUsingGETRequest{
		ApiService: a,
		ctx: ctx,
		securityIdentifier: securityIdentifier,
	}
}

// Execute executes the request
//  @return ListingView
func (a *ListingControllerAPIService) GetListingUsingGETExecute(r ApiGetListingUsingGETRequest) (*ListingView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListingView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListingControllerAPIService.GetListingUsingGET")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/listings/{securityIdentifier}"
	localVarPath = strings.Replace(localVarPath, "{"+"securityIdentifier"+"}", url.PathEscape(parameterValueToString(r.securityIdentifier, "securityIdentifier")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOutstandingSharesUsingGETRequest struct {
	ctx context.Context
	ApiService *ListingControllerAPIService
	securityIdentifier string
}

func (r ApiGetOutstandingSharesUsingGETRequest) Execute() (int64, *http.Response, error) {
	return r.ApiService.GetOutstandingSharesUsingGETExecute(r)
}

/*
GetOutstandingSharesUsingGET Returns Outstanding Shares

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param securityIdentifier Security Identifier
 @return ApiGetOutstandingSharesUsingGETRequest
*/
func (a *ListingControllerAPIService) GetOutstandingSharesUsingGET(ctx context.Context, securityIdentifier string) ApiGetOutstandingSharesUsingGETRequest {
	return ApiGetOutstandingSharesUsingGETRequest{
		ApiService: a,
		ctx: ctx,
		securityIdentifier: securityIdentifier,
	}
}

// Execute executes the request
//  @return int64
func (a *ListingControllerAPIService) GetOutstandingSharesUsingGETExecute(r ApiGetOutstandingSharesUsingGETRequest) (int64, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  int64
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListingControllerAPIService.GetOutstandingSharesUsingGET")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/listings/outstandingshares/{securityIdentifier}"
	localVarPath = strings.Replace(localVarPath, "{"+"securityIdentifier"+"}", url.PathEscape(parameterValueToString(r.securityIdentifier, "securityIdentifier")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetProfileV1UsingGETRequest struct {
	ctx context.Context
	ApiService *ListingControllerAPIService
	securityIdentifier string
	securitiesAccountId *string
}

// Shareholder&#39;s securities account id
func (r ApiGetProfileV1UsingGETRequest) SecuritiesAccountId(securitiesAccountId string) ApiGetProfileV1UsingGETRequest {
	r.securitiesAccountId = &securitiesAccountId
	return r
}

func (r ApiGetProfileV1UsingGETRequest) Execute() (*ListingProfileView, *http.Response, error) {
	return r.ApiService.GetProfileV1UsingGETExecute(r)
}

/*
GetProfileV1UsingGET Gets listing profile

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param securityIdentifier Security identifier
 @return ApiGetProfileV1UsingGETRequest

Deprecated
*/
func (a *ListingControllerAPIService) GetProfileV1UsingGET(ctx context.Context, securityIdentifier string) ApiGetProfileV1UsingGETRequest {
	return ApiGetProfileV1UsingGETRequest{
		ApiService: a,
		ctx: ctx,
		securityIdentifier: securityIdentifier,
	}
}

// Execute executes the request
//  @return ListingProfileView
// Deprecated
func (a *ListingControllerAPIService) GetProfileV1UsingGETExecute(r ApiGetProfileV1UsingGETRequest) (*ListingProfileView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListingProfileView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListingControllerAPIService.GetProfileV1UsingGET")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/listingprofiles/{securityIdentifier}"
	localVarPath = strings.Replace(localVarPath, "{"+"securityIdentifier"+"}", url.PathEscape(parameterValueToString(r.securityIdentifier, "securityIdentifier")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.securitiesAccountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "securitiesAccountId", r.securitiesAccountId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListHistorizedCompanyDataUsingGETRequest struct {
	ctx context.Context
	ApiService *ListingControllerAPIService
	securityIdentifier string
	page *int32
	size *int32
	sort *[]string
}

// Results page you want to retrieve (0..N)
func (r ApiListHistorizedCompanyDataUsingGETRequest) Page(page int32) ApiListHistorizedCompanyDataUsingGETRequest {
	r.page = &page
	return r
}

// Number of records per page
func (r ApiListHistorizedCompanyDataUsingGETRequest) Size(size int32) ApiListHistorizedCompanyDataUsingGETRequest {
	r.size = &size
	return r
}

// Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
func (r ApiListHistorizedCompanyDataUsingGETRequest) Sort(sort []string) ApiListHistorizedCompanyDataUsingGETRequest {
	r.sort = &sort
	return r
}

func (r ApiListHistorizedCompanyDataUsingGETRequest) Execute() (*PageHistorizedCompanyDataView, *http.Response, error) {
	return r.ApiService.ListHistorizedCompanyDataUsingGETExecute(r)
}

/*
ListHistorizedCompanyDataUsingGET Lists all historized company data

Sorted ascending by startDate as default

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param securityIdentifier Security Identifier
 @return ApiListHistorizedCompanyDataUsingGETRequest
*/
func (a *ListingControllerAPIService) ListHistorizedCompanyDataUsingGET(ctx context.Context, securityIdentifier string) ApiListHistorizedCompanyDataUsingGETRequest {
	return ApiListHistorizedCompanyDataUsingGETRequest{
		ApiService: a,
		ctx: ctx,
		securityIdentifier: securityIdentifier,
	}
}

// Execute executes the request
//  @return PageHistorizedCompanyDataView
func (a *ListingControllerAPIService) ListHistorizedCompanyDataUsingGETExecute(r ApiListHistorizedCompanyDataUsingGETRequest) (*PageHistorizedCompanyDataView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PageHistorizedCompanyDataView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListingControllerAPIService.ListHistorizedCompanyDataUsingGET")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/historizedcompanydata/{securityIdentifier}"
	localVarPath = strings.Replace(localVarPath, "{"+"securityIdentifier"+"}", url.PathEscape(parameterValueToString(r.securityIdentifier, "securityIdentifier")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "")
	}
	if r.sort != nil {
		t := *r.sort
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sort", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sort", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListHistorizedListingDataUsingGETRequest struct {
	ctx context.Context
	ApiService *ListingControllerAPIService
	securityIdentifier string
	page *int32
	size *int32
	sort *[]string
}

// Results page you want to retrieve (0..N)
func (r ApiListHistorizedListingDataUsingGETRequest) Page(page int32) ApiListHistorizedListingDataUsingGETRequest {
	r.page = &page
	return r
}

// Number of records per page
func (r ApiListHistorizedListingDataUsingGETRequest) Size(size int32) ApiListHistorizedListingDataUsingGETRequest {
	r.size = &size
	return r
}

// Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
func (r ApiListHistorizedListingDataUsingGETRequest) Sort(sort []string) ApiListHistorizedListingDataUsingGETRequest {
	r.sort = &sort
	return r
}

func (r ApiListHistorizedListingDataUsingGETRequest) Execute() (*PageHistorizedListingDataView, *http.Response, error) {
	return r.ApiService.ListHistorizedListingDataUsingGETExecute(r)
}

/*
ListHistorizedListingDataUsingGET Lists all historized listing data

Sorted ascending by startDate as default

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param securityIdentifier Security Identifier
 @return ApiListHistorizedListingDataUsingGETRequest
*/
func (a *ListingControllerAPIService) ListHistorizedListingDataUsingGET(ctx context.Context, securityIdentifier string) ApiListHistorizedListingDataUsingGETRequest {
	return ApiListHistorizedListingDataUsingGETRequest{
		ApiService: a,
		ctx: ctx,
		securityIdentifier: securityIdentifier,
	}
}

// Execute executes the request
//  @return PageHistorizedListingDataView
func (a *ListingControllerAPIService) ListHistorizedListingDataUsingGETExecute(r ApiListHistorizedListingDataUsingGETRequest) (*PageHistorizedListingDataView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PageHistorizedListingDataView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListingControllerAPIService.ListHistorizedListingDataUsingGET")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/historizedlistingdata/{securityIdentifier}"
	localVarPath = strings.Replace(localVarPath, "{"+"securityIdentifier"+"}", url.PathEscape(parameterValueToString(r.securityIdentifier, "securityIdentifier")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "")
	}
	if r.sort != nil {
		t := *r.sort
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sort", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sort", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListListingsUsingGETRequest struct {
	ctx context.Context
	ApiService *ListingControllerAPIService
	page *int32
	size *int32
	sort *[]string
}

// Results page you want to retrieve (0..N)
func (r ApiListListingsUsingGETRequest) Page(page int32) ApiListListingsUsingGETRequest {
	r.page = &page
	return r
}

// Number of records per page
func (r ApiListListingsUsingGETRequest) Size(size int32) ApiListListingsUsingGETRequest {
	r.size = &size
	return r
}

// Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
func (r ApiListListingsUsingGETRequest) Sort(sort []string) ApiListListingsUsingGETRequest {
	r.sort = &sort
	return r
}

func (r ApiListListingsUsingGETRequest) Execute() (*PageListingView, *http.Response, error) {
	return r.ApiService.ListListingsUsingGETExecute(r)
}

/*
ListListingsUsingGET Lists all listings without end date

Sorted ascending by startDate as default

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListListingsUsingGETRequest
*/
func (a *ListingControllerAPIService) ListListingsUsingGET(ctx context.Context) ApiListListingsUsingGETRequest {
	return ApiListListingsUsingGETRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PageListingView
func (a *ListingControllerAPIService) ListListingsUsingGETExecute(r ApiListListingsUsingGETRequest) (*PageListingView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PageListingView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListingControllerAPIService.ListListingsUsingGET")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/listings"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "")
	}
	if r.sort != nil {
		t := *r.sort
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sort", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sort", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListListingsV1UsingGETRequest struct {
	ctx context.Context
	ApiService *ListingControllerAPIService
}

func (r ApiListListingsV1UsingGETRequest) Execute() (*ListingView, *http.Response, error) {
	return r.ApiService.ListListingsV1UsingGETExecute(r)
}

/*
ListListingsV1UsingGET Lists all listings without end date (200 max.)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListListingsV1UsingGETRequest

Deprecated
*/
func (a *ListingControllerAPIService) ListListingsV1UsingGET(ctx context.Context) ApiListListingsV1UsingGETRequest {
	return ApiListListingsV1UsingGETRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ListingView
// Deprecated
func (a *ListingControllerAPIService) ListListingsV1UsingGETExecute(r ApiListListingsV1UsingGETRequest) (*ListingView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ListingView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListingControllerAPIService.ListListingsV1UsingGET")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/listings/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchListingsUsingGETRequest struct {
	ctx context.Context
	ApiService *ListingControllerAPIService
	securityIdentifier string
}

func (r ApiSearchListingsUsingGETRequest) Execute() (*ShareholderView, *http.Response, error) {
	return r.ApiService.SearchListingsUsingGETExecute(r)
}

/*
SearchListingsUsingGET Lists Shareholders

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param securityIdentifier Security Identifier
 @return ApiSearchListingsUsingGETRequest
*/
func (a *ListingControllerAPIService) SearchListingsUsingGET(ctx context.Context, securityIdentifier string) ApiSearchListingsUsingGETRequest {
	return ApiSearchListingsUsingGETRequest{
		ApiService: a,
		ctx: ctx,
		securityIdentifier: securityIdentifier,
	}
}

// Execute executes the request
//  @return ShareholderView
func (a *ListingControllerAPIService) SearchListingsUsingGETExecute(r ApiSearchListingsUsingGETRequest) (*ShareholderView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ShareholderView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ListingControllerAPIService.SearchListingsUsingGET")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/shareholders/{securityIdentifier}"
	localVarPath = strings.Replace(localVarPath, "{"+"securityIdentifier"+"}", url.PathEscape(parameterValueToString(r.securityIdentifier, "securityIdentifier")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
