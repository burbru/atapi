/*
Api Documentation

Api Documentation

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package atapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// AllianceControllerAPIService AllianceControllerAPI service
type AllianceControllerAPIService service

type ApiAddToAllianceUsingPOSTRequest struct {
	ctx context.Context
	ApiService *AllianceControllerAPIService
	allianceId *string
	role *string
	userId *string
}

// Alliance id
func (r ApiAddToAllianceUsingPOSTRequest) AllianceId(allianceId string) ApiAddToAllianceUsingPOSTRequest {
	r.allianceId = &allianceId
	return r
}

// Role
func (r ApiAddToAllianceUsingPOSTRequest) Role(role string) ApiAddToAllianceUsingPOSTRequest {
	r.role = &role
	return r
}

// User id
func (r ApiAddToAllianceUsingPOSTRequest) UserId(userId string) ApiAddToAllianceUsingPOSTRequest {
	r.userId = &userId
	return r
}

func (r ApiAddToAllianceUsingPOSTRequest) Execute() (*AllianceMembershipView, *http.Response, error) {
	return r.ApiService.AddToAllianceUsingPOSTExecute(r)
}

/*
AddToAllianceUsingPOST Adds user to alliance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAddToAllianceUsingPOSTRequest
*/
func (a *AllianceControllerAPIService) AddToAllianceUsingPOST(ctx context.Context) ApiAddToAllianceUsingPOSTRequest {
	return ApiAddToAllianceUsingPOSTRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AllianceMembershipView
func (a *AllianceControllerAPIService) AddToAllianceUsingPOSTExecute(r ApiAddToAllianceUsingPOSTRequest) (*AllianceMembershipView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AllianceMembershipView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AllianceControllerAPIService.AddToAllianceUsingPOST")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/alliancememberships"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.allianceId == nil {
		return localVarReturnValue, nil, reportError("allianceId is required and must be specified")
	}
	if r.role == nil {
		return localVarReturnValue, nil, reportError("role is required and must be specified")
	}
	if r.userId == nil {
		return localVarReturnValue, nil, reportError("userId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "allianceId", r.allianceId, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "role", r.role, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiChangeAllianceMembershipUsingPUTRequest struct {
	ctx context.Context
	ApiService *AllianceControllerAPIService
	membershipId string
	role *string
}

// Role
func (r ApiChangeAllianceMembershipUsingPUTRequest) Role(role string) ApiChangeAllianceMembershipUsingPUTRequest {
	r.role = &role
	return r
}

func (r ApiChangeAllianceMembershipUsingPUTRequest) Execute() (*AllianceMembershipView, *http.Response, error) {
	return r.ApiService.ChangeAllianceMembershipUsingPUTExecute(r)
}

/*
ChangeAllianceMembershipUsingPUT Change alliance membership

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param membershipId Membership id
 @return ApiChangeAllianceMembershipUsingPUTRequest
*/
func (a *AllianceControllerAPIService) ChangeAllianceMembershipUsingPUT(ctx context.Context, membershipId string) ApiChangeAllianceMembershipUsingPUTRequest {
	return ApiChangeAllianceMembershipUsingPUTRequest{
		ApiService: a,
		ctx: ctx,
		membershipId: membershipId,
	}
}

// Execute executes the request
//  @return AllianceMembershipView
func (a *AllianceControllerAPIService) ChangeAllianceMembershipUsingPUTExecute(r ApiChangeAllianceMembershipUsingPUTRequest) (*AllianceMembershipView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AllianceMembershipView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AllianceControllerAPIService.ChangeAllianceMembershipUsingPUT")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/alliancememberships/{membershipId}"
	localVarPath = strings.Replace(localVarPath, "{"+"membershipId"+"}", url.PathEscape(parameterValueToString(r.membershipId, "membershipId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.role != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "role", r.role, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateAllianceUsingPOSTRequest struct {
	ctx context.Context
	ApiService *AllianceControllerAPIService
	description *string
	locale *string
	name *string
	logoUrl *string
}

// Description
func (r ApiCreateAllianceUsingPOSTRequest) Description(description string) ApiCreateAllianceUsingPOSTRequest {
	r.description = &description
	return r
}

// Locale
func (r ApiCreateAllianceUsingPOSTRequest) Locale(locale string) ApiCreateAllianceUsingPOSTRequest {
	r.locale = &locale
	return r
}

// Name
func (r ApiCreateAllianceUsingPOSTRequest) Name(name string) ApiCreateAllianceUsingPOSTRequest {
	r.name = &name
	return r
}

// Logo URL
func (r ApiCreateAllianceUsingPOSTRequest) LogoUrl(logoUrl string) ApiCreateAllianceUsingPOSTRequest {
	r.logoUrl = &logoUrl
	return r
}

func (r ApiCreateAllianceUsingPOSTRequest) Execute() (*AllianceView, *http.Response, error) {
	return r.ApiService.CreateAllianceUsingPOSTExecute(r)
}

/*
CreateAllianceUsingPOST Creates alliance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateAllianceUsingPOSTRequest
*/
func (a *AllianceControllerAPIService) CreateAllianceUsingPOST(ctx context.Context) ApiCreateAllianceUsingPOSTRequest {
	return ApiCreateAllianceUsingPOSTRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AllianceView
func (a *AllianceControllerAPIService) CreateAllianceUsingPOSTExecute(r ApiCreateAllianceUsingPOSTRequest) (*AllianceView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AllianceView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AllianceControllerAPIService.CreateAllianceUsingPOST")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/alliances"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.description == nil {
		return localVarReturnValue, nil, reportError("description is required and must be specified")
	}
	if r.locale == nil {
		return localVarReturnValue, nil, reportError("locale is required and must be specified")
	}
	if r.name == nil {
		return localVarReturnValue, nil, reportError("name is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	if r.logoUrl != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "logoUrl", r.logoUrl, "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteAllianceUsingDELETERequest struct {
	ctx context.Context
	ApiService *AllianceControllerAPIService
	allianceId string
}

func (r ApiDeleteAllianceUsingDELETERequest) Execute() (string, *http.Response, error) {
	return r.ApiService.DeleteAllianceUsingDELETEExecute(r)
}

/*
DeleteAllianceUsingDELETE Deletes alliance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param allianceId Alliance id
 @return ApiDeleteAllianceUsingDELETERequest
*/
func (a *AllianceControllerAPIService) DeleteAllianceUsingDELETE(ctx context.Context, allianceId string) ApiDeleteAllianceUsingDELETERequest {
	return ApiDeleteAllianceUsingDELETERequest{
		ApiService: a,
		ctx: ctx,
		allianceId: allianceId,
	}
}

// Execute executes the request
//  @return string
func (a *AllianceControllerAPIService) DeleteAllianceUsingDELETEExecute(r ApiDeleteAllianceUsingDELETERequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AllianceControllerAPIService.DeleteAllianceUsingDELETE")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/alliances/{allianceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"allianceId"+"}", url.PathEscape(parameterValueToString(r.allianceId, "allianceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteMyAllianceMembershipUsingDELETERequest struct {
	ctx context.Context
	ApiService *AllianceControllerAPIService
}

func (r ApiDeleteMyAllianceMembershipUsingDELETERequest) Execute() (*AllianceMembershipView, *http.Response, error) {
	return r.ApiService.DeleteMyAllianceMembershipUsingDELETEExecute(r)
}

/*
DeleteMyAllianceMembershipUsingDELETE Delete logged in user's alliance membership

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteMyAllianceMembershipUsingDELETERequest
*/
func (a *AllianceControllerAPIService) DeleteMyAllianceMembershipUsingDELETE(ctx context.Context) ApiDeleteMyAllianceMembershipUsingDELETERequest {
	return ApiDeleteMyAllianceMembershipUsingDELETERequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AllianceMembershipView
func (a *AllianceControllerAPIService) DeleteMyAllianceMembershipUsingDELETEExecute(r ApiDeleteMyAllianceMembershipUsingDELETERequest) (*AllianceMembershipView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AllianceMembershipView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AllianceControllerAPIService.DeleteMyAllianceMembershipUsingDELETE")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/my/alliancemembership"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiEditAllianceUsingPUTRequest struct {
	ctx context.Context
	ApiService *AllianceControllerAPIService
	allianceId string
	locale *string
	name *string
	description *string
	logoUrl *string
}

// Locale
func (r ApiEditAllianceUsingPUTRequest) Locale(locale string) ApiEditAllianceUsingPUTRequest {
	r.locale = &locale
	return r
}

// Name
func (r ApiEditAllianceUsingPUTRequest) Name(name string) ApiEditAllianceUsingPUTRequest {
	r.name = &name
	return r
}

// Description
func (r ApiEditAllianceUsingPUTRequest) Description(description string) ApiEditAllianceUsingPUTRequest {
	r.description = &description
	return r
}

// Logo URL
func (r ApiEditAllianceUsingPUTRequest) LogoUrl(logoUrl string) ApiEditAllianceUsingPUTRequest {
	r.logoUrl = &logoUrl
	return r
}

func (r ApiEditAllianceUsingPUTRequest) Execute() (*AllianceView, *http.Response, error) {
	return r.ApiService.EditAllianceUsingPUTExecute(r)
}

/*
EditAllianceUsingPUT Changes alliance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param allianceId Alliance id
 @return ApiEditAllianceUsingPUTRequest
*/
func (a *AllianceControllerAPIService) EditAllianceUsingPUT(ctx context.Context, allianceId string) ApiEditAllianceUsingPUTRequest {
	return ApiEditAllianceUsingPUTRequest{
		ApiService: a,
		ctx: ctx,
		allianceId: allianceId,
	}
}

// Execute executes the request
//  @return AllianceView
func (a *AllianceControllerAPIService) EditAllianceUsingPUTExecute(r ApiEditAllianceUsingPUTRequest) (*AllianceView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AllianceView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AllianceControllerAPIService.EditAllianceUsingPUT")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/alliances/{allianceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"allianceId"+"}", url.PathEscape(parameterValueToString(r.allianceId, "allianceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.locale == nil {
		return localVarReturnValue, nil, reportError("locale is required and must be specified")
	}
	if r.name == nil {
		return localVarReturnValue, nil, reportError("name is required and must be specified")
	}

	if r.description != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "description", r.description, "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	if r.logoUrl != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "logoUrl", r.logoUrl, "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "name", r.name, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAllianceMembershipsUsingGETRequest struct {
	ctx context.Context
	ApiService *AllianceControllerAPIService
	allianceId *string
}

// Alliance id
func (r ApiGetAllianceMembershipsUsingGETRequest) AllianceId(allianceId string) ApiGetAllianceMembershipsUsingGETRequest {
	r.allianceId = &allianceId
	return r
}

func (r ApiGetAllianceMembershipsUsingGETRequest) Execute() (*AllianceMembershipView, *http.Response, error) {
	return r.ApiService.GetAllianceMembershipsUsingGETExecute(r)
}

/*
GetAllianceMembershipsUsingGET Lists memberships of alliance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAllianceMembershipsUsingGETRequest
*/
func (a *AllianceControllerAPIService) GetAllianceMembershipsUsingGET(ctx context.Context) ApiGetAllianceMembershipsUsingGETRequest {
	return ApiGetAllianceMembershipsUsingGETRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AllianceMembershipView
func (a *AllianceControllerAPIService) GetAllianceMembershipsUsingGETExecute(r ApiGetAllianceMembershipsUsingGETRequest) (*AllianceMembershipView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AllianceMembershipView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AllianceControllerAPIService.GetAllianceMembershipsUsingGET")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/alliancememberships"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.allianceId == nil {
		return localVarReturnValue, nil, reportError("allianceId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "allianceId", r.allianceId, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAllianceUsingGETRequest struct {
	ctx context.Context
	ApiService *AllianceControllerAPIService
	allianceId string
}

func (r ApiGetAllianceUsingGETRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.GetAllianceUsingGETExecute(r)
}

/*
GetAllianceUsingGET Returns alliance

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param allianceId Message alliance id
 @return ApiGetAllianceUsingGETRequest
*/
func (a *AllianceControllerAPIService) GetAllianceUsingGET(ctx context.Context, allianceId string) ApiGetAllianceUsingGETRequest {
	return ApiGetAllianceUsingGETRequest{
		ApiService: a,
		ctx: ctx,
		allianceId: allianceId,
	}
}

// Execute executes the request
//  @return string
func (a *AllianceControllerAPIService) GetAllianceUsingGETExecute(r ApiGetAllianceUsingGETRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AllianceControllerAPIService.GetAllianceUsingGET")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/alliances/{allianceId}"
	localVarPath = strings.Replace(localVarPath, "{"+"allianceId"+"}", url.PathEscape(parameterValueToString(r.allianceId, "allianceId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMyAllianceMembershipUsingGETRequest struct {
	ctx context.Context
	ApiService *AllianceControllerAPIService
}

func (r ApiGetMyAllianceMembershipUsingGETRequest) Execute() (*AllianceMembershipView, *http.Response, error) {
	return r.ApiService.GetMyAllianceMembershipUsingGETExecute(r)
}

/*
GetMyAllianceMembershipUsingGET Returns logged in user's alliance membership

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetMyAllianceMembershipUsingGETRequest
*/
func (a *AllianceControllerAPIService) GetMyAllianceMembershipUsingGET(ctx context.Context) ApiGetMyAllianceMembershipUsingGETRequest {
	return ApiGetMyAllianceMembershipUsingGETRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AllianceMembershipView
func (a *AllianceControllerAPIService) GetMyAllianceMembershipUsingGETExecute(r ApiGetMyAllianceMembershipUsingGETRequest) (*AllianceMembershipView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AllianceMembershipView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AllianceControllerAPIService.GetMyAllianceMembershipUsingGET")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/my/alliancemembership"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUserAllianceMembershipUsingGETRequest struct {
	ctx context.Context
	ApiService *AllianceControllerAPIService
	username *string
}

// Username
func (r ApiGetUserAllianceMembershipUsingGETRequest) Username(username string) ApiGetUserAllianceMembershipUsingGETRequest {
	r.username = &username
	return r
}

func (r ApiGetUserAllianceMembershipUsingGETRequest) Execute() (*AllianceMembershipView, *http.Response, error) {
	return r.ApiService.GetUserAllianceMembershipUsingGETExecute(r)
}

/*
GetUserAllianceMembershipUsingGET Returns user's alliance membership

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetUserAllianceMembershipUsingGETRequest
*/
func (a *AllianceControllerAPIService) GetUserAllianceMembershipUsingGET(ctx context.Context) ApiGetUserAllianceMembershipUsingGETRequest {
	return ApiGetUserAllianceMembershipUsingGETRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AllianceMembershipView
func (a *AllianceControllerAPIService) GetUserAllianceMembershipUsingGETExecute(r ApiGetUserAllianceMembershipUsingGETRequest) (*AllianceMembershipView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AllianceMembershipView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AllianceControllerAPIService.GetUserAllianceMembershipUsingGET")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/alliancememberships/username"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.username == nil {
		return localVarReturnValue, nil, reportError("username is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "username", r.username, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListAlliancesUsingGETRequest struct {
	ctx context.Context
	ApiService *AllianceControllerAPIService
	page *int32
	size *int32
	sort *[]string
}

// Results page you want to retrieve (0..N)
func (r ApiListAlliancesUsingGETRequest) Page(page int32) ApiListAlliancesUsingGETRequest {
	r.page = &page
	return r
}

// Number of records per page
func (r ApiListAlliancesUsingGETRequest) Size(size int32) ApiListAlliancesUsingGETRequest {
	r.size = &size
	return r
}

// Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
func (r ApiListAlliancesUsingGETRequest) Sort(sort []string) ApiListAlliancesUsingGETRequest {
	r.sort = &sort
	return r
}

func (r ApiListAlliancesUsingGETRequest) Execute() (*PageAllianceWithDetailsView, *http.Response, error) {
	return r.ApiService.ListAlliancesUsingGETExecute(r)
}

/*
ListAlliancesUsingGET Lists alliances

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListAlliancesUsingGETRequest
*/
func (a *AllianceControllerAPIService) ListAlliancesUsingGET(ctx context.Context) ApiListAlliancesUsingGETRequest {
	return ApiListAlliancesUsingGETRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PageAllianceWithDetailsView
func (a *AllianceControllerAPIService) ListAlliancesUsingGETExecute(r ApiListAlliancesUsingGETRequest) (*PageAllianceWithDetailsView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PageAllianceWithDetailsView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AllianceControllerAPIService.ListAlliancesUsingGET")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/alliances"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "")
	}
	if r.sort != nil {
		t := *r.sort
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sort", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sort", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRemoveAllianceMembershipOfAllianceUsingDELETERequest struct {
	ctx context.Context
	ApiService *AllianceControllerAPIService
	allianceId *string
}

// Alliance Id
func (r ApiRemoveAllianceMembershipOfAllianceUsingDELETERequest) AllianceId(allianceId string) ApiRemoveAllianceMembershipOfAllianceUsingDELETERequest {
	r.allianceId = &allianceId
	return r
}

func (r ApiRemoveAllianceMembershipOfAllianceUsingDELETERequest) Execute() (*MessagePrototype, *http.Response, error) {
	return r.ApiService.RemoveAllianceMembershipOfAllianceUsingDELETEExecute(r)
}

/*
RemoveAllianceMembershipOfAllianceUsingDELETE Removes alliance membership

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRemoveAllianceMembershipOfAllianceUsingDELETERequest
*/
func (a *AllianceControllerAPIService) RemoveAllianceMembershipOfAllianceUsingDELETE(ctx context.Context) ApiRemoveAllianceMembershipOfAllianceUsingDELETERequest {
	return ApiRemoveAllianceMembershipOfAllianceUsingDELETERequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MessagePrototype
func (a *AllianceControllerAPIService) RemoveAllianceMembershipOfAllianceUsingDELETEExecute(r ApiRemoveAllianceMembershipOfAllianceUsingDELETERequest) (*MessagePrototype, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MessagePrototype
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AllianceControllerAPIService.RemoveAllianceMembershipOfAllianceUsingDELETE")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/alliancememberships"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.allianceId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "allianceId", r.allianceId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRemoveAllianceMembershipUsingDELETERequest struct {
	ctx context.Context
	ApiService *AllianceControllerAPIService
	membershipId string
}

func (r ApiRemoveAllianceMembershipUsingDELETERequest) Execute() (*MessagePrototype, *http.Response, error) {
	return r.ApiService.RemoveAllianceMembershipUsingDELETEExecute(r)
}

/*
RemoveAllianceMembershipUsingDELETE Removes alliance membership

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param membershipId Membership id
 @return ApiRemoveAllianceMembershipUsingDELETERequest
*/
func (a *AllianceControllerAPIService) RemoveAllianceMembershipUsingDELETE(ctx context.Context, membershipId string) ApiRemoveAllianceMembershipUsingDELETERequest {
	return ApiRemoveAllianceMembershipUsingDELETERequest{
		ApiService: a,
		ctx: ctx,
		membershipId: membershipId,
	}
}

// Execute executes the request
//  @return MessagePrototype
func (a *AllianceControllerAPIService) RemoveAllianceMembershipUsingDELETEExecute(r ApiRemoveAllianceMembershipUsingDELETERequest) (*MessagePrototype, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MessagePrototype
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AllianceControllerAPIService.RemoveAllianceMembershipUsingDELETE")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/alliancememberships/{membershipId}"
	localVarPath = strings.Replace(localVarPath, "{"+"membershipId"+"}", url.PathEscape(parameterValueToString(r.membershipId, "membershipId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiReturnAllianceMembershipUsingGETRequest struct {
	ctx context.Context
	ApiService *AllianceControllerAPIService
	membershipId string
}

func (r ApiReturnAllianceMembershipUsingGETRequest) Execute() (*AllianceMembershipView, *http.Response, error) {
	return r.ApiService.ReturnAllianceMembershipUsingGETExecute(r)
}

/*
ReturnAllianceMembershipUsingGET Return alliance membership

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param membershipId Membership id
 @return ApiReturnAllianceMembershipUsingGETRequest
*/
func (a *AllianceControllerAPIService) ReturnAllianceMembershipUsingGET(ctx context.Context, membershipId string) ApiReturnAllianceMembershipUsingGETRequest {
	return ApiReturnAllianceMembershipUsingGETRequest{
		ApiService: a,
		ctx: ctx,
		membershipId: membershipId,
	}
}

// Execute executes the request
//  @return AllianceMembershipView
func (a *AllianceControllerAPIService) ReturnAllianceMembershipUsingGETExecute(r ApiReturnAllianceMembershipUsingGETRequest) (*AllianceMembershipView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AllianceMembershipView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "AllianceControllerAPIService.ReturnAllianceMembershipUsingGET")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/alliancememberships/{membershipId}"
	localVarPath = strings.Replace(localVarPath, "{"+"membershipId"+"}", url.PathEscape(parameterValueToString(r.membershipId, "membershipId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
