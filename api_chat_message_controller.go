/*
Api Documentation

Api Documentation

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package atapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
)


// ChatMessageControllerAPIService ChatMessageControllerAPI service
type ChatMessageControllerAPIService service

type ApiDeleteMessageUsingDELETERequest struct {
	ctx context.Context
	ApiService *ChatMessageControllerAPIService
	messageId string
}

func (r ApiDeleteMessageUsingDELETERequest) Execute() (*MessagePrototype, *http.Response, error) {
	return r.ApiService.DeleteMessageUsingDELETEExecute(r)
}

/*
DeleteMessageUsingDELETE Deletes message

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param messageId Message id
 @return ApiDeleteMessageUsingDELETERequest
*/
func (a *ChatMessageControllerAPIService) DeleteMessageUsingDELETE(ctx context.Context, messageId string) ApiDeleteMessageUsingDELETERequest {
	return ApiDeleteMessageUsingDELETERequest{
		ApiService: a,
		ctx: ctx,
		messageId: messageId,
	}
}

// Execute executes the request
//  @return MessagePrototype
func (a *ChatMessageControllerAPIService) DeleteMessageUsingDELETEExecute(r ApiDeleteMessageUsingDELETERequest) (*MessagePrototype, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MessagePrototype
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChatMessageControllerAPIService.DeleteMessageUsingDELETE")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/messages/{messageId}"
	localVarPath = strings.Replace(localVarPath, "{"+"messageId"+"}", url.PathEscape(parameterValueToString(r.messageId, "messageId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteMessageV1UsingDELETERequest struct {
	ctx context.Context
	ApiService *ChatMessageControllerAPIService
	messageId string
}

func (r ApiDeleteMessageV1UsingDELETERequest) Execute() (*MessagePrototype, *http.Response, error) {
	return r.ApiService.DeleteMessageV1UsingDELETEExecute(r)
}

/*
DeleteMessageV1UsingDELETE Deletes message

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param messageId Message id
 @return ApiDeleteMessageV1UsingDELETERequest

Deprecated
*/
func (a *ChatMessageControllerAPIService) DeleteMessageV1UsingDELETE(ctx context.Context, messageId string) ApiDeleteMessageV1UsingDELETERequest {
	return ApiDeleteMessageV1UsingDELETERequest{
		ApiService: a,
		ctx: ctx,
		messageId: messageId,
	}
}

// Execute executes the request
//  @return MessagePrototype
// Deprecated
func (a *ChatMessageControllerAPIService) DeleteMessageV1UsingDELETEExecute(r ApiDeleteMessageV1UsingDELETERequest) (*MessagePrototype, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MessagePrototype
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChatMessageControllerAPIService.DeleteMessageV1UsingDELETE")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/messages/{messageId}"
	localVarPath = strings.Replace(localVarPath, "{"+"messageId"+"}", url.PathEscape(parameterValueToString(r.messageId, "messageId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMessageUsingGETRequest struct {
	ctx context.Context
	ApiService *ChatMessageControllerAPIService
	messageId string
}

func (r ApiGetMessageUsingGETRequest) Execute() (*MessageView, *http.Response, error) {
	return r.ApiService.GetMessageUsingGETExecute(r)
}

/*
GetMessageUsingGET Returns mesage

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param messageId Message id
 @return ApiGetMessageUsingGETRequest
*/
func (a *ChatMessageControllerAPIService) GetMessageUsingGET(ctx context.Context, messageId string) ApiGetMessageUsingGETRequest {
	return ApiGetMessageUsingGETRequest{
		ApiService: a,
		ctx: ctx,
		messageId: messageId,
	}
}

// Execute executes the request
//  @return MessageView
func (a *ChatMessageControllerAPIService) GetMessageUsingGETExecute(r ApiGetMessageUsingGETRequest) (*MessageView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MessageView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChatMessageControllerAPIService.GetMessageUsingGET")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/messages/{messageId}"
	localVarPath = strings.Replace(localVarPath, "{"+"messageId"+"}", url.PathEscape(parameterValueToString(r.messageId, "messageId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMessageV1UsingGETRequest struct {
	ctx context.Context
	ApiService *ChatMessageControllerAPIService
	messageId string
}

func (r ApiGetMessageV1UsingGETRequest) Execute() (*MessageView, *http.Response, error) {
	return r.ApiService.GetMessageV1UsingGETExecute(r)
}

/*
GetMessageV1UsingGET Returns mesage

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param messageId Message id
 @return ApiGetMessageV1UsingGETRequest

Deprecated
*/
func (a *ChatMessageControllerAPIService) GetMessageV1UsingGET(ctx context.Context, messageId string) ApiGetMessageV1UsingGETRequest {
	return ApiGetMessageV1UsingGETRequest{
		ApiService: a,
		ctx: ctx,
		messageId: messageId,
	}
}

// Execute executes the request
//  @return MessageView
// Deprecated
func (a *ChatMessageControllerAPIService) GetMessageV1UsingGETExecute(r ApiGetMessageV1UsingGETRequest) (*MessageView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MessageView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChatMessageControllerAPIService.GetMessageV1UsingGET")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/messages/{messageId}"
	localVarPath = strings.Replace(localVarPath, "{"+"messageId"+"}", url.PathEscape(parameterValueToString(r.messageId, "messageId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMessagesOfChatUsingGETRequest struct {
	ctx context.Context
	ApiService *ChatMessageControllerAPIService
	chatId string
	afterDate *int64
	beforeDate *int64
}

// After date
func (r ApiGetMessagesOfChatUsingGETRequest) AfterDate(afterDate int64) ApiGetMessagesOfChatUsingGETRequest {
	r.afterDate = &afterDate
	return r
}

// Before date
func (r ApiGetMessagesOfChatUsingGETRequest) BeforeDate(beforeDate int64) ApiGetMessagesOfChatUsingGETRequest {
	r.beforeDate = &beforeDate
	return r
}

func (r ApiGetMessagesOfChatUsingGETRequest) Execute() (*MessageView, *http.Response, error) {
	return r.ApiService.GetMessagesOfChatUsingGETExecute(r)
}

/*
GetMessagesOfChatUsingGET Returns messages of chat

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param chatId Chat id
 @return ApiGetMessagesOfChatUsingGETRequest
*/
func (a *ChatMessageControllerAPIService) GetMessagesOfChatUsingGET(ctx context.Context, chatId string) ApiGetMessagesOfChatUsingGETRequest {
	return ApiGetMessagesOfChatUsingGETRequest{
		ApiService: a,
		ctx: ctx,
		chatId: chatId,
	}
}

// Execute executes the request
//  @return MessageView
func (a *ChatMessageControllerAPIService) GetMessagesOfChatUsingGETExecute(r ApiGetMessagesOfChatUsingGETRequest) (*MessageView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MessageView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChatMessageControllerAPIService.GetMessagesOfChatUsingGET")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/messages/chat/{chatId}"
	localVarPath = strings.Replace(localVarPath, "{"+"chatId"+"}", url.PathEscape(parameterValueToString(r.chatId, "chatId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.afterDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "afterDate", r.afterDate, "")
	}
	if r.beforeDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "beforeDate", r.beforeDate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMessagesOfChatV1UsingGETRequest struct {
	ctx context.Context
	ApiService *ChatMessageControllerAPIService
	chatId string
	afterDate *int64
	beforeDate *int64
}

// After date
func (r ApiGetMessagesOfChatV1UsingGETRequest) AfterDate(afterDate int64) ApiGetMessagesOfChatV1UsingGETRequest {
	r.afterDate = &afterDate
	return r
}

// Before date
func (r ApiGetMessagesOfChatV1UsingGETRequest) BeforeDate(beforeDate int64) ApiGetMessagesOfChatV1UsingGETRequest {
	r.beforeDate = &beforeDate
	return r
}

func (r ApiGetMessagesOfChatV1UsingGETRequest) Execute() (*MessageView, *http.Response, error) {
	return r.ApiService.GetMessagesOfChatV1UsingGETExecute(r)
}

/*
GetMessagesOfChatV1UsingGET Returns messages of chat

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param chatId Chat id
 @return ApiGetMessagesOfChatV1UsingGETRequest

Deprecated
*/
func (a *ChatMessageControllerAPIService) GetMessagesOfChatV1UsingGET(ctx context.Context, chatId string) ApiGetMessagesOfChatV1UsingGETRequest {
	return ApiGetMessagesOfChatV1UsingGETRequest{
		ApiService: a,
		ctx: ctx,
		chatId: chatId,
	}
}

// Execute executes the request
//  @return MessageView
// Deprecated
func (a *ChatMessageControllerAPIService) GetMessagesOfChatV1UsingGETExecute(r ApiGetMessagesOfChatV1UsingGETRequest) (*MessageView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MessageView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChatMessageControllerAPIService.GetMessagesOfChatV1UsingGET")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/messages/chat/{chatId}"
	localVarPath = strings.Replace(localVarPath, "{"+"chatId"+"}", url.PathEscape(parameterValueToString(r.chatId, "chatId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.afterDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "afterDate", r.afterDate, "")
	}
	if r.beforeDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "beforeDate", r.beforeDate, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUnreadMessagesUsingGETRequest struct {
	ctx context.Context
	ApiService *ChatMessageControllerAPIService
	chatId *string
}

// ID of the chat group
func (r ApiGetUnreadMessagesUsingGETRequest) ChatId(chatId string) ApiGetUnreadMessagesUsingGETRequest {
	r.chatId = &chatId
	return r
}

func (r ApiGetUnreadMessagesUsingGETRequest) Execute() (*MessageView, *http.Response, error) {
	return r.ApiService.GetUnreadMessagesUsingGETExecute(r)
}

/*
GetUnreadMessagesUsingGET Returns unread messages

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetUnreadMessagesUsingGETRequest
*/
func (a *ChatMessageControllerAPIService) GetUnreadMessagesUsingGET(ctx context.Context) ApiGetUnreadMessagesUsingGETRequest {
	return ApiGetUnreadMessagesUsingGETRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MessageView
func (a *ChatMessageControllerAPIService) GetUnreadMessagesUsingGETExecute(r ApiGetUnreadMessagesUsingGETRequest) (*MessageView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MessageView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChatMessageControllerAPIService.GetUnreadMessagesUsingGET")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/messages/unread"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.chatId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "chatId", r.chatId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUnreadMessagesV1UsingGETRequest struct {
	ctx context.Context
	ApiService *ChatMessageControllerAPIService
	chatId *string
}

// ID of the chat group
func (r ApiGetUnreadMessagesV1UsingGETRequest) ChatId(chatId string) ApiGetUnreadMessagesV1UsingGETRequest {
	r.chatId = &chatId
	return r
}

func (r ApiGetUnreadMessagesV1UsingGETRequest) Execute() (*MessageView, *http.Response, error) {
	return r.ApiService.GetUnreadMessagesV1UsingGETExecute(r)
}

/*
GetUnreadMessagesV1UsingGET Returns unread messages

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetUnreadMessagesV1UsingGETRequest

Deprecated
*/
func (a *ChatMessageControllerAPIService) GetUnreadMessagesV1UsingGET(ctx context.Context) ApiGetUnreadMessagesV1UsingGETRequest {
	return ApiGetUnreadMessagesV1UsingGETRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MessageView
// Deprecated
func (a *ChatMessageControllerAPIService) GetUnreadMessagesV1UsingGETExecute(r ApiGetUnreadMessagesV1UsingGETRequest) (*MessageView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MessageView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChatMessageControllerAPIService.GetUnreadMessagesV1UsingGET")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/messages/unread"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.chatId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "chatId", r.chatId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSendMessageUsingPOSTRequest struct {
	ctx context.Context
	ApiService *ChatMessageControllerAPIService
	chatId *string
	content *string
}

// ID of the chat group
func (r ApiSendMessageUsingPOSTRequest) ChatId(chatId string) ApiSendMessageUsingPOSTRequest {
	r.chatId = &chatId
	return r
}

// Content
func (r ApiSendMessageUsingPOSTRequest) Content(content string) ApiSendMessageUsingPOSTRequest {
	r.content = &content
	return r
}

func (r ApiSendMessageUsingPOSTRequest) Execute() (*MessageView, *http.Response, error) {
	return r.ApiService.SendMessageUsingPOSTExecute(r)
}

/*
SendMessageUsingPOST Sends a new message

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSendMessageUsingPOSTRequest
*/
func (a *ChatMessageControllerAPIService) SendMessageUsingPOST(ctx context.Context) ApiSendMessageUsingPOSTRequest {
	return ApiSendMessageUsingPOSTRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MessageView
func (a *ChatMessageControllerAPIService) SendMessageUsingPOSTExecute(r ApiSendMessageUsingPOSTRequest) (*MessageView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MessageView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChatMessageControllerAPIService.SendMessageUsingPOST")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/messages"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.content == nil {
		return localVarReturnValue, nil, reportError("content is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "chatId", r.chatId, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "content", r.content, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSendMessageV1UsingPOSTRequest struct {
	ctx context.Context
	ApiService *ChatMessageControllerAPIService
	chatId *string
	content *string
}

// ID of the chat group
func (r ApiSendMessageV1UsingPOSTRequest) ChatId(chatId string) ApiSendMessageV1UsingPOSTRequest {
	r.chatId = &chatId
	return r
}

// Content
func (r ApiSendMessageV1UsingPOSTRequest) Content(content string) ApiSendMessageV1UsingPOSTRequest {
	r.content = &content
	return r
}

func (r ApiSendMessageV1UsingPOSTRequest) Execute() (*MessageView, *http.Response, error) {
	return r.ApiService.SendMessageV1UsingPOSTExecute(r)
}

/*
SendMessageV1UsingPOST Sends a new message

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSendMessageV1UsingPOSTRequest

Deprecated
*/
func (a *ChatMessageControllerAPIService) SendMessageV1UsingPOST(ctx context.Context) ApiSendMessageV1UsingPOSTRequest {
	return ApiSendMessageV1UsingPOSTRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MessageView
// Deprecated
func (a *ChatMessageControllerAPIService) SendMessageV1UsingPOSTExecute(r ApiSendMessageV1UsingPOSTRequest) (*MessageView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MessageView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChatMessageControllerAPIService.SendMessageV1UsingPOST")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/messages"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.content == nil {
		return localVarReturnValue, nil, reportError("content is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "chatId", r.chatId, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "content", r.content, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateMessageReadUsingPUTRequest struct {
	ctx context.Context
	ApiService *ChatMessageControllerAPIService
	messageId *string
}

// Message ID
func (r ApiUpdateMessageReadUsingPUTRequest) MessageId(messageId string) ApiUpdateMessageReadUsingPUTRequest {
	r.messageId = &messageId
	return r
}

func (r ApiUpdateMessageReadUsingPUTRequest) Execute() (*MessageView, *http.Response, error) {
	return r.ApiService.UpdateMessageReadUsingPUTExecute(r)
}

/*
UpdateMessageReadUsingPUT Sets a message as read by logged in user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateMessageReadUsingPUTRequest
*/
func (a *ChatMessageControllerAPIService) UpdateMessageReadUsingPUT(ctx context.Context) ApiUpdateMessageReadUsingPUTRequest {
	return ApiUpdateMessageReadUsingPUTRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MessageView
func (a *ChatMessageControllerAPIService) UpdateMessageReadUsingPUTExecute(r ApiUpdateMessageReadUsingPUTRequest) (*MessageView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MessageView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChatMessageControllerAPIService.UpdateMessageReadUsingPUT")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/messages/read"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.messageId == nil {
		return localVarReturnValue, nil, reportError("messageId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "messageId", r.messageId, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateMessageReadV1UsingPUTRequest struct {
	ctx context.Context
	ApiService *ChatMessageControllerAPIService
	messageId *string
}

// Message ID
func (r ApiUpdateMessageReadV1UsingPUTRequest) MessageId(messageId string) ApiUpdateMessageReadV1UsingPUTRequest {
	r.messageId = &messageId
	return r
}

func (r ApiUpdateMessageReadV1UsingPUTRequest) Execute() (*MessageView, *http.Response, error) {
	return r.ApiService.UpdateMessageReadV1UsingPUTExecute(r)
}

/*
UpdateMessageReadV1UsingPUT Sets a message as read by logged in user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiUpdateMessageReadV1UsingPUTRequest

Deprecated
*/
func (a *ChatMessageControllerAPIService) UpdateMessageReadV1UsingPUT(ctx context.Context) ApiUpdateMessageReadV1UsingPUTRequest {
	return ApiUpdateMessageReadV1UsingPUTRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MessageView
// Deprecated
func (a *ChatMessageControllerAPIService) UpdateMessageReadV1UsingPUTExecute(r ApiUpdateMessageReadV1UsingPUTRequest) (*MessageView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MessageView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChatMessageControllerAPIService.UpdateMessageReadV1UsingPUT")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/messages/read"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.messageId == nil {
		return localVarReturnValue, nil, reportError("messageId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "messageId", r.messageId, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
