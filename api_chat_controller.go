/*
Api Documentation

Api Documentation

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package atapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// ChatControllerAPIService ChatControllerAPI service
type ChatControllerAPIService service

type ApiAddToChatByUsernameUsingPUTRequest struct {
	ctx context.Context
	ApiService *ChatControllerAPIService
	chatId *string
	username *string
}

// Chat id
func (r ApiAddToChatByUsernameUsingPUTRequest) ChatId(chatId string) ApiAddToChatByUsernameUsingPUTRequest {
	r.chatId = &chatId
	return r
}

// Username
func (r ApiAddToChatByUsernameUsingPUTRequest) Username(username string) ApiAddToChatByUsernameUsingPUTRequest {
	r.username = &username
	return r
}

func (r ApiAddToChatByUsernameUsingPUTRequest) Execute() (*ChatView, *http.Response, error) {
	return r.ApiService.AddToChatByUsernameUsingPUTExecute(r)
}

/*
AddToChatByUsernameUsingPUT Adds user to chat

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAddToChatByUsernameUsingPUTRequest

Deprecated
*/
func (a *ChatControllerAPIService) AddToChatByUsernameUsingPUT(ctx context.Context) ApiAddToChatByUsernameUsingPUTRequest {
	return ApiAddToChatByUsernameUsingPUTRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ChatView
// Deprecated
func (a *ChatControllerAPIService) AddToChatByUsernameUsingPUTExecute(r ApiAddToChatByUsernameUsingPUTRequest) (*ChatView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChatView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChatControllerAPIService.AddToChatByUsernameUsingPUT")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/chats/adduser/username"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.username == nil {
		return localVarReturnValue, nil, reportError("username is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "chatId", r.chatId, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "username", r.username, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAddToChatUsingPOSTRequest struct {
	ctx context.Context
	ApiService *ChatControllerAPIService
	chatId *string
	userId *string
	role *string
}

// Chat id
func (r ApiAddToChatUsingPOSTRequest) ChatId(chatId string) ApiAddToChatUsingPOSTRequest {
	r.chatId = &chatId
	return r
}

// User id
func (r ApiAddToChatUsingPOSTRequest) UserId(userId string) ApiAddToChatUsingPOSTRequest {
	r.userId = &userId
	return r
}

// Role
func (r ApiAddToChatUsingPOSTRequest) Role(role string) ApiAddToChatUsingPOSTRequest {
	r.role = &role
	return r
}

func (r ApiAddToChatUsingPOSTRequest) Execute() (*ChatMembershipView, *http.Response, error) {
	return r.ApiService.AddToChatUsingPOSTExecute(r)
}

/*
AddToChatUsingPOST Adds user to chat

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAddToChatUsingPOSTRequest
*/
func (a *ChatControllerAPIService) AddToChatUsingPOST(ctx context.Context) ApiAddToChatUsingPOSTRequest {
	return ApiAddToChatUsingPOSTRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ChatMembershipView
func (a *ChatControllerAPIService) AddToChatUsingPOSTExecute(r ApiAddToChatUsingPOSTRequest) (*ChatMembershipView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChatMembershipView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChatControllerAPIService.AddToChatUsingPOST")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/chatmemberships"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.userId == nil {
		return localVarReturnValue, nil, reportError("userId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "chatId", r.chatId, "")
	if r.role != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "role", r.role, "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAddToChatV1UsingPUTRequest struct {
	ctx context.Context
	ApiService *ChatControllerAPIService
	chatId *string
	userId *string
}

// Chat id
func (r ApiAddToChatV1UsingPUTRequest) ChatId(chatId string) ApiAddToChatV1UsingPUTRequest {
	r.chatId = &chatId
	return r
}

// User id
func (r ApiAddToChatV1UsingPUTRequest) UserId(userId string) ApiAddToChatV1UsingPUTRequest {
	r.userId = &userId
	return r
}

func (r ApiAddToChatV1UsingPUTRequest) Execute() (*ChatView, *http.Response, error) {
	return r.ApiService.AddToChatV1UsingPUTExecute(r)
}

/*
AddToChatV1UsingPUT Adds user to chat

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAddToChatV1UsingPUTRequest

Deprecated
*/
func (a *ChatControllerAPIService) AddToChatV1UsingPUT(ctx context.Context) ApiAddToChatV1UsingPUTRequest {
	return ApiAddToChatV1UsingPUTRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ChatView
// Deprecated
func (a *ChatControllerAPIService) AddToChatV1UsingPUTExecute(r ApiAddToChatV1UsingPUTRequest) (*ChatView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChatView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChatControllerAPIService.AddToChatV1UsingPUT")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/chats/adduser/userid"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.userId == nil {
		return localVarReturnValue, nil, reportError("userId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "chatId", r.chatId, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiChangeChatMembershipUsingPUTRequest struct {
	ctx context.Context
	ApiService *ChatControllerAPIService
	membershipId string
	role *string
}

// Role
func (r ApiChangeChatMembershipUsingPUTRequest) Role(role string) ApiChangeChatMembershipUsingPUTRequest {
	r.role = &role
	return r
}

func (r ApiChangeChatMembershipUsingPUTRequest) Execute() (*ChatMembershipView, *http.Response, error) {
	return r.ApiService.ChangeChatMembershipUsingPUTExecute(r)
}

/*
ChangeChatMembershipUsingPUT Change chat membership

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param membershipId Membership id
 @return ApiChangeChatMembershipUsingPUTRequest
*/
func (a *ChatControllerAPIService) ChangeChatMembershipUsingPUT(ctx context.Context, membershipId string) ApiChangeChatMembershipUsingPUTRequest {
	return ApiChangeChatMembershipUsingPUTRequest{
		ApiService: a,
		ctx: ctx,
		membershipId: membershipId,
	}
}

// Execute executes the request
//  @return ChatMembershipView
func (a *ChatControllerAPIService) ChangeChatMembershipUsingPUTExecute(r ApiChangeChatMembershipUsingPUTRequest) (*ChatMembershipView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChatMembershipView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChatControllerAPIService.ChangeChatMembershipUsingPUT")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/chatmemberships/{membershipId}"
	localVarPath = strings.Replace(localVarPath, "{"+"membershipId"+"}", url.PathEscape(parameterValueToString(r.membershipId, "membershipId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.role != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "role", r.role, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiChangeChatUsingPUTRequest struct {
	ctx context.Context
	ApiService *ChatControllerAPIService
	chatId string
	chatName *string
	public *bool
	readonly *bool
}

// Chat name
func (r ApiChangeChatUsingPUTRequest) ChatName(chatName string) ApiChangeChatUsingPUTRequest {
	r.chatName = &chatName
	return r
}

// Public
func (r ApiChangeChatUsingPUTRequest) Public(public bool) ApiChangeChatUsingPUTRequest {
	r.public = &public
	return r
}

// Readonly
func (r ApiChangeChatUsingPUTRequest) Readonly(readonly bool) ApiChangeChatUsingPUTRequest {
	r.readonly = &readonly
	return r
}

func (r ApiChangeChatUsingPUTRequest) Execute() (*PlainChatView, *http.Response, error) {
	return r.ApiService.ChangeChatUsingPUTExecute(r)
}

/*
ChangeChatUsingPUT Changes chat properties

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param chatId Chat id
 @return ApiChangeChatUsingPUTRequest
*/
func (a *ChatControllerAPIService) ChangeChatUsingPUT(ctx context.Context, chatId string) ApiChangeChatUsingPUTRequest {
	return ApiChangeChatUsingPUTRequest{
		ApiService: a,
		ctx: ctx,
		chatId: chatId,
	}
}

// Execute executes the request
//  @return PlainChatView
func (a *ChatControllerAPIService) ChangeChatUsingPUTExecute(r ApiChangeChatUsingPUTRequest) (*PlainChatView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PlainChatView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChatControllerAPIService.ChangeChatUsingPUT")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/chats/{chatId}"
	localVarPath = strings.Replace(localVarPath, "{"+"chatId"+"}", url.PathEscape(parameterValueToString(r.chatId, "chatId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.chatName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "chatName", r.chatName, "")
	}
	if r.public != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "public", r.public, "")
	}
	if r.readonly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "readonly", r.readonly, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiChangeChatV1UsingPUTRequest struct {
	ctx context.Context
	ApiService *ChatControllerAPIService
	chatId string
	chatName *string
	readonly *bool
}

// Chat name
func (r ApiChangeChatV1UsingPUTRequest) ChatName(chatName string) ApiChangeChatV1UsingPUTRequest {
	r.chatName = &chatName
	return r
}

// Readonly
func (r ApiChangeChatV1UsingPUTRequest) Readonly(readonly bool) ApiChangeChatV1UsingPUTRequest {
	r.readonly = &readonly
	return r
}

func (r ApiChangeChatV1UsingPUTRequest) Execute() (*ChatView, *http.Response, error) {
	return r.ApiService.ChangeChatV1UsingPUTExecute(r)
}

/*
ChangeChatV1UsingPUT Changes chat properties

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param chatId Chat id
 @return ApiChangeChatV1UsingPUTRequest

Deprecated
*/
func (a *ChatControllerAPIService) ChangeChatV1UsingPUT(ctx context.Context, chatId string) ApiChangeChatV1UsingPUTRequest {
	return ApiChangeChatV1UsingPUTRequest{
		ApiService: a,
		ctx: ctx,
		chatId: chatId,
	}
}

// Execute executes the request
//  @return ChatView
// Deprecated
func (a *ChatControllerAPIService) ChangeChatV1UsingPUTExecute(r ApiChangeChatV1UsingPUTRequest) (*ChatView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChatView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChatControllerAPIService.ChangeChatV1UsingPUT")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/chats/{chatId}"
	localVarPath = strings.Replace(localVarPath, "{"+"chatId"+"}", url.PathEscape(parameterValueToString(r.chatId, "chatId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.chatName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "chatName", r.chatName, "")
	}
	if r.readonly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "readonly", r.readonly, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateChatByIdsUsingPOSTRequest struct {
	ctx context.Context
	ApiService *ChatControllerAPIService
	participants *[]string
	chatName *string
	readonly *bool
}

// Participants user ids
func (r ApiCreateChatByIdsUsingPOSTRequest) Participants(participants []string) ApiCreateChatByIdsUsingPOSTRequest {
	r.participants = &participants
	return r
}

// Chat name
func (r ApiCreateChatByIdsUsingPOSTRequest) ChatName(chatName string) ApiCreateChatByIdsUsingPOSTRequest {
	r.chatName = &chatName
	return r
}

// Readonly
func (r ApiCreateChatByIdsUsingPOSTRequest) Readonly(readonly bool) ApiCreateChatByIdsUsingPOSTRequest {
	r.readonly = &readonly
	return r
}

func (r ApiCreateChatByIdsUsingPOSTRequest) Execute() (*ChatView, *http.Response, error) {
	return r.ApiService.CreateChatByIdsUsingPOSTExecute(r)
}

/*
CreateChatByIdsUsingPOST Creates a new chat

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateChatByIdsUsingPOSTRequest

Deprecated
*/
func (a *ChatControllerAPIService) CreateChatByIdsUsingPOST(ctx context.Context) ApiCreateChatByIdsUsingPOSTRequest {
	return ApiCreateChatByIdsUsingPOSTRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ChatView
// Deprecated
func (a *ChatControllerAPIService) CreateChatByIdsUsingPOSTExecute(r ApiCreateChatByIdsUsingPOSTRequest) (*ChatView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChatView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChatControllerAPIService.CreateChatByIdsUsingPOST")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/chats/userids"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.participants == nil {
		return localVarReturnValue, nil, reportError("participants is required and must be specified")
	}

	if r.chatName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "chatName", r.chatName, "")
	}
	{
		t := *r.participants
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "participants[]", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "participants[]", t, "multi")
		}
	}
	if r.readonly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "readonly", r.readonly, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateChatByNamesUsingPOSTRequest struct {
	ctx context.Context
	ApiService *ChatControllerAPIService
	participants *[]string
	chatName *string
	readonly *bool
}

// Participants usernames
func (r ApiCreateChatByNamesUsingPOSTRequest) Participants(participants []string) ApiCreateChatByNamesUsingPOSTRequest {
	r.participants = &participants
	return r
}

// Chat name
func (r ApiCreateChatByNamesUsingPOSTRequest) ChatName(chatName string) ApiCreateChatByNamesUsingPOSTRequest {
	r.chatName = &chatName
	return r
}

// Readonly
func (r ApiCreateChatByNamesUsingPOSTRequest) Readonly(readonly bool) ApiCreateChatByNamesUsingPOSTRequest {
	r.readonly = &readonly
	return r
}

func (r ApiCreateChatByNamesUsingPOSTRequest) Execute() (*ChatView, *http.Response, error) {
	return r.ApiService.CreateChatByNamesUsingPOSTExecute(r)
}

/*
CreateChatByNamesUsingPOST Creates a new chat

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateChatByNamesUsingPOSTRequest

Deprecated
*/
func (a *ChatControllerAPIService) CreateChatByNamesUsingPOST(ctx context.Context) ApiCreateChatByNamesUsingPOSTRequest {
	return ApiCreateChatByNamesUsingPOSTRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ChatView
// Deprecated
func (a *ChatControllerAPIService) CreateChatByNamesUsingPOSTExecute(r ApiCreateChatByNamesUsingPOSTRequest) (*ChatView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChatView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChatControllerAPIService.CreateChatByNamesUsingPOST")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/chats/usernames"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.participants == nil {
		return localVarReturnValue, nil, reportError("participants is required and must be specified")
	}

	if r.chatName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "chatName", r.chatName, "")
	}
	{
		t := *r.participants
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "participants[]", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "participants[]", t, "multi")
		}
	}
	if r.readonly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "readonly", r.readonly, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateChatUsingPOSTRequest struct {
	ctx context.Context
	ApiService *ChatControllerAPIService
	chatName *string
	public *bool
	readonly *bool
}

// Chat name
func (r ApiCreateChatUsingPOSTRequest) ChatName(chatName string) ApiCreateChatUsingPOSTRequest {
	r.chatName = &chatName
	return r
}

// Public
func (r ApiCreateChatUsingPOSTRequest) Public(public bool) ApiCreateChatUsingPOSTRequest {
	r.public = &public
	return r
}

// Readonly
func (r ApiCreateChatUsingPOSTRequest) Readonly(readonly bool) ApiCreateChatUsingPOSTRequest {
	r.readonly = &readonly
	return r
}

func (r ApiCreateChatUsingPOSTRequest) Execute() (*ChatView, *http.Response, error) {
	return r.ApiService.CreateChatUsingPOSTExecute(r)
}

/*
CreateChatUsingPOST Creates a new chat

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateChatUsingPOSTRequest
*/
func (a *ChatControllerAPIService) CreateChatUsingPOST(ctx context.Context) ApiCreateChatUsingPOSTRequest {
	return ApiCreateChatUsingPOSTRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ChatView
func (a *ChatControllerAPIService) CreateChatUsingPOSTExecute(r ApiCreateChatUsingPOSTRequest) (*ChatView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChatView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChatControllerAPIService.CreateChatUsingPOST")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/chats"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.chatName != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "chatName", r.chatName, "")
	}
	if r.public != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "public", r.public, "")
	}
	if r.readonly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "readonly", r.readonly, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteChatUsingDELETERequest struct {
	ctx context.Context
	ApiService *ChatControllerAPIService
	chatId string
}

func (r ApiDeleteChatUsingDELETERequest) Execute() (*MessagePrototype, *http.Response, error) {
	return r.ApiService.DeleteChatUsingDELETEExecute(r)
}

/*
DeleteChatUsingDELETE Deletes chat

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param chatId Chat id
 @return ApiDeleteChatUsingDELETERequest
*/
func (a *ChatControllerAPIService) DeleteChatUsingDELETE(ctx context.Context, chatId string) ApiDeleteChatUsingDELETERequest {
	return ApiDeleteChatUsingDELETERequest{
		ApiService: a,
		ctx: ctx,
		chatId: chatId,
	}
}

// Execute executes the request
//  @return MessagePrototype
func (a *ChatControllerAPIService) DeleteChatUsingDELETEExecute(r ApiDeleteChatUsingDELETERequest) (*MessagePrototype, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MessagePrototype
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChatControllerAPIService.DeleteChatUsingDELETE")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/chats/{chatId}"
	localVarPath = strings.Replace(localVarPath, "{"+"chatId"+"}", url.PathEscape(parameterValueToString(r.chatId, "chatId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteChatV1UsingDELETERequest struct {
	ctx context.Context
	ApiService *ChatControllerAPIService
	chatId string
}

func (r ApiDeleteChatV1UsingDELETERequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.DeleteChatV1UsingDELETEExecute(r)
}

/*
DeleteChatV1UsingDELETE Deletes chat

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param chatId Chat id
 @return ApiDeleteChatV1UsingDELETERequest

Deprecated
*/
func (a *ChatControllerAPIService) DeleteChatV1UsingDELETE(ctx context.Context, chatId string) ApiDeleteChatV1UsingDELETERequest {
	return ApiDeleteChatV1UsingDELETERequest{
		ApiService: a,
		ctx: ctx,
		chatId: chatId,
	}
}

// Execute executes the request
//  @return map[string]interface{}
// Deprecated
func (a *ChatControllerAPIService) DeleteChatV1UsingDELETEExecute(r ApiDeleteChatV1UsingDELETERequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChatControllerAPIService.DeleteChatV1UsingDELETE")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/chats/{chatId}"
	localVarPath = strings.Replace(localVarPath, "{"+"chatId"+"}", url.PathEscape(parameterValueToString(r.chatId, "chatId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetChatMembershipUsingGETRequest struct {
	ctx context.Context
	ApiService *ChatControllerAPIService
	membershipId string
}

func (r ApiGetChatMembershipUsingGETRequest) Execute() (*ChatMembershipView, *http.Response, error) {
	return r.ApiService.GetChatMembershipUsingGETExecute(r)
}

/*
GetChatMembershipUsingGET Returns chat membership

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param membershipId Membership id
 @return ApiGetChatMembershipUsingGETRequest
*/
func (a *ChatControllerAPIService) GetChatMembershipUsingGET(ctx context.Context, membershipId string) ApiGetChatMembershipUsingGETRequest {
	return ApiGetChatMembershipUsingGETRequest{
		ApiService: a,
		ctx: ctx,
		membershipId: membershipId,
	}
}

// Execute executes the request
//  @return ChatMembershipView
func (a *ChatControllerAPIService) GetChatMembershipUsingGETExecute(r ApiGetChatMembershipUsingGETRequest) (*ChatMembershipView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChatMembershipView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChatControllerAPIService.GetChatMembershipUsingGET")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/chatmemberships/{membershipId}"
	localVarPath = strings.Replace(localVarPath, "{"+"membershipId"+"}", url.PathEscape(parameterValueToString(r.membershipId, "membershipId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetChatMembershipsUsingGETRequest struct {
	ctx context.Context
	ApiService *ChatControllerAPIService
	chatId *string
}

// Chat id
func (r ApiGetChatMembershipsUsingGETRequest) ChatId(chatId string) ApiGetChatMembershipsUsingGETRequest {
	r.chatId = &chatId
	return r
}

func (r ApiGetChatMembershipsUsingGETRequest) Execute() (*ChatMembershipView, *http.Response, error) {
	return r.ApiService.GetChatMembershipsUsingGETExecute(r)
}

/*
GetChatMembershipsUsingGET Returns chat memberships of chat

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetChatMembershipsUsingGETRequest
*/
func (a *ChatControllerAPIService) GetChatMembershipsUsingGET(ctx context.Context) ApiGetChatMembershipsUsingGETRequest {
	return ApiGetChatMembershipsUsingGETRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ChatMembershipView
func (a *ChatControllerAPIService) GetChatMembershipsUsingGETExecute(r ApiGetChatMembershipsUsingGETRequest) (*ChatMembershipView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChatMembershipView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChatControllerAPIService.GetChatMembershipsUsingGET")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/chatmemberships"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "chatId", r.chatId, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetChatUsingGETRequest struct {
	ctx context.Context
	ApiService *ChatControllerAPIService
	chatId string
}

func (r ApiGetChatUsingGETRequest) Execute() (*PlainChatView, *http.Response, error) {
	return r.ApiService.GetChatUsingGETExecute(r)
}

/*
GetChatUsingGET Returns chat

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param chatId Chat id
 @return ApiGetChatUsingGETRequest
*/
func (a *ChatControllerAPIService) GetChatUsingGET(ctx context.Context, chatId string) ApiGetChatUsingGETRequest {
	return ApiGetChatUsingGETRequest{
		ApiService: a,
		ctx: ctx,
		chatId: chatId,
	}
}

// Execute executes the request
//  @return PlainChatView
func (a *ChatControllerAPIService) GetChatUsingGETExecute(r ApiGetChatUsingGETRequest) (*PlainChatView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PlainChatView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChatControllerAPIService.GetChatUsingGET")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/chats/{chatId}"
	localVarPath = strings.Replace(localVarPath, "{"+"chatId"+"}", url.PathEscape(parameterValueToString(r.chatId, "chatId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetChatV1UsingGETRequest struct {
	ctx context.Context
	ApiService *ChatControllerAPIService
	chatId string
}

func (r ApiGetChatV1UsingGETRequest) Execute() (*ChatView, *http.Response, error) {
	return r.ApiService.GetChatV1UsingGETExecute(r)
}

/*
GetChatV1UsingGET Returns chat

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param chatId Chat id
 @return ApiGetChatV1UsingGETRequest

Deprecated
*/
func (a *ChatControllerAPIService) GetChatV1UsingGET(ctx context.Context, chatId string) ApiGetChatV1UsingGETRequest {
	return ApiGetChatV1UsingGETRequest{
		ApiService: a,
		ctx: ctx,
		chatId: chatId,
	}
}

// Execute executes the request
//  @return ChatView
// Deprecated
func (a *ChatControllerAPIService) GetChatV1UsingGETExecute(r ApiGetChatV1UsingGETRequest) (*ChatView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChatView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChatControllerAPIService.GetChatV1UsingGET")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/chats/{chatId}"
	localVarPath = strings.Replace(localVarPath, "{"+"chatId"+"}", url.PathEscape(parameterValueToString(r.chatId, "chatId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetChatsUsingGETRequest struct {
	ctx context.Context
	ApiService *ChatControllerAPIService
}

func (r ApiGetChatsUsingGETRequest) Execute() (*CompactChatView, *http.Response, error) {
	return r.ApiService.GetChatsUsingGETExecute(r)
}

/*
GetChatsUsingGET Returns chats with unread messages

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetChatsUsingGETRequest
*/
func (a *ChatControllerAPIService) GetChatsUsingGET(ctx context.Context) ApiGetChatsUsingGETRequest {
	return ApiGetChatsUsingGETRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CompactChatView
func (a *ChatControllerAPIService) GetChatsUsingGETExecute(r ApiGetChatsUsingGETRequest) (*CompactChatView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CompactChatView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChatControllerAPIService.GetChatsUsingGET")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/my/chats/unread"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetChatsV1UsingGETRequest struct {
	ctx context.Context
	ApiService *ChatControllerAPIService
}

func (r ApiGetChatsV1UsingGETRequest) Execute() (*CompactChatView, *http.Response, error) {
	return r.ApiService.GetChatsV1UsingGETExecute(r)
}

/*
GetChatsV1UsingGET Returns chats with unread messages

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetChatsV1UsingGETRequest

Deprecated
*/
func (a *ChatControllerAPIService) GetChatsV1UsingGET(ctx context.Context) ApiGetChatsV1UsingGETRequest {
	return ApiGetChatsV1UsingGETRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CompactChatView
// Deprecated
func (a *ChatControllerAPIService) GetChatsV1UsingGETExecute(r ApiGetChatsV1UsingGETRequest) (*CompactChatView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CompactChatView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChatControllerAPIService.GetChatsV1UsingGET")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/chats/unread"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMyChatsUsingGETRequest struct {
	ctx context.Context
	ApiService *ChatControllerAPIService
}

func (r ApiGetMyChatsUsingGETRequest) Execute() (*ChatView, *http.Response, error) {
	return r.ApiService.GetMyChatsUsingGETExecute(r)
}

/*
GetMyChatsUsingGET Lists chats in which logged in user participates

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetMyChatsUsingGETRequest
*/
func (a *ChatControllerAPIService) GetMyChatsUsingGET(ctx context.Context) ApiGetMyChatsUsingGETRequest {
	return ApiGetMyChatsUsingGETRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ChatView
func (a *ChatControllerAPIService) GetMyChatsUsingGETExecute(r ApiGetMyChatsUsingGETRequest) (*ChatView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChatView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChatControllerAPIService.GetMyChatsUsingGET")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/my/chats"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMyChatsV1UsingGETRequest struct {
	ctx context.Context
	ApiService *ChatControllerAPIService
}

func (r ApiGetMyChatsV1UsingGETRequest) Execute() (*ChatView, *http.Response, error) {
	return r.ApiService.GetMyChatsV1UsingGETExecute(r)
}

/*
GetMyChatsV1UsingGET Lists chats in which logged in user participates

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetMyChatsV1UsingGETRequest

Deprecated
*/
func (a *ChatControllerAPIService) GetMyChatsV1UsingGET(ctx context.Context) ApiGetMyChatsV1UsingGETRequest {
	return ApiGetMyChatsV1UsingGETRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ChatView
// Deprecated
func (a *ChatControllerAPIService) GetMyChatsV1UsingGETExecute(r ApiGetMyChatsV1UsingGETRequest) (*ChatView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChatView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChatControllerAPIService.GetMyChatsV1UsingGET")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/chats"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUnreadChatsCountUsingGETRequest struct {
	ctx context.Context
	ApiService *ChatControllerAPIService
}

func (r ApiGetUnreadChatsCountUsingGETRequest) Execute() (int64, *http.Response, error) {
	return r.ApiService.GetUnreadChatsCountUsingGETExecute(r)
}

/*
GetUnreadChatsCountUsingGET Returns number of chats with unread messages

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetUnreadChatsCountUsingGETRequest
*/
func (a *ChatControllerAPIService) GetUnreadChatsCountUsingGET(ctx context.Context) ApiGetUnreadChatsCountUsingGETRequest {
	return ApiGetUnreadChatsCountUsingGETRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return int64
func (a *ChatControllerAPIService) GetUnreadChatsCountUsingGETExecute(r ApiGetUnreadChatsCountUsingGETRequest) (int64, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  int64
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChatControllerAPIService.GetUnreadChatsCountUsingGET")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/my/chats/unread/count"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListPublicChatsUsingGETRequest struct {
	ctx context.Context
	ApiService *ChatControllerAPIService
	memberId *string
}

// User ID of chat member
func (r ApiListPublicChatsUsingGETRequest) MemberId(memberId string) ApiListPublicChatsUsingGETRequest {
	r.memberId = &memberId
	return r
}

func (r ApiListPublicChatsUsingGETRequest) Execute() (*ChatRoomView, *http.Response, error) {
	return r.ApiService.ListPublicChatsUsingGETExecute(r)
}

/*
ListPublicChatsUsingGET Lists public chatrooms

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListPublicChatsUsingGETRequest
*/
func (a *ChatControllerAPIService) ListPublicChatsUsingGET(ctx context.Context) ApiListPublicChatsUsingGETRequest {
	return ApiListPublicChatsUsingGETRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ChatRoomView
func (a *ChatControllerAPIService) ListPublicChatsUsingGETExecute(r ApiListPublicChatsUsingGETRequest) (*ChatRoomView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChatRoomView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChatControllerAPIService.ListPublicChatsUsingGET")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/chatrooms"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.memberId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "memberId", r.memberId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMarkChatAsReadUsingPUTRequest struct {
	ctx context.Context
	ApiService *ChatControllerAPIService
	chatId *string
}

// Chat ID
func (r ApiMarkChatAsReadUsingPUTRequest) ChatId(chatId string) ApiMarkChatAsReadUsingPUTRequest {
	r.chatId = &chatId
	return r
}

func (r ApiMarkChatAsReadUsingPUTRequest) Execute() (*ChatView, *http.Response, error) {
	return r.ApiService.MarkChatAsReadUsingPUTExecute(r)
}

/*
MarkChatAsReadUsingPUT Sets a chat as read by logged in user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMarkChatAsReadUsingPUTRequest
*/
func (a *ChatControllerAPIService) MarkChatAsReadUsingPUT(ctx context.Context) ApiMarkChatAsReadUsingPUTRequest {
	return ApiMarkChatAsReadUsingPUTRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ChatView
func (a *ChatControllerAPIService) MarkChatAsReadUsingPUTExecute(r ApiMarkChatAsReadUsingPUTRequest) (*ChatView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChatView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChatControllerAPIService.MarkChatAsReadUsingPUT")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/my/chats/read"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "chatId", r.chatId, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiMarkChatAsReadV1UsingPUTRequest struct {
	ctx context.Context
	ApiService *ChatControllerAPIService
	chatId *string
}

// Chat ID
func (r ApiMarkChatAsReadV1UsingPUTRequest) ChatId(chatId string) ApiMarkChatAsReadV1UsingPUTRequest {
	r.chatId = &chatId
	return r
}

func (r ApiMarkChatAsReadV1UsingPUTRequest) Execute() (*ChatView, *http.Response, error) {
	return r.ApiService.MarkChatAsReadV1UsingPUTExecute(r)
}

/*
MarkChatAsReadV1UsingPUT Sets a chat as read by logged in user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiMarkChatAsReadV1UsingPUTRequest

Deprecated
*/
func (a *ChatControllerAPIService) MarkChatAsReadV1UsingPUT(ctx context.Context) ApiMarkChatAsReadV1UsingPUTRequest {
	return ApiMarkChatAsReadV1UsingPUTRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ChatView
// Deprecated
func (a *ChatControllerAPIService) MarkChatAsReadV1UsingPUTExecute(r ApiMarkChatAsReadV1UsingPUTRequest) (*ChatView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChatView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChatControllerAPIService.MarkChatAsReadV1UsingPUT")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/chats/read"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "chatId", r.chatId, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiQuitChatUsingPUTRequest struct {
	ctx context.Context
	ApiService *ChatControllerAPIService
	chatId string
}

func (r ApiQuitChatUsingPUTRequest) Execute() (*ChatView, *http.Response, error) {
	return r.ApiService.QuitChatUsingPUTExecute(r)
}

/*
QuitChatUsingPUT Removes logged in user from chat

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param chatId Chat id
 @return ApiQuitChatUsingPUTRequest

Deprecated
*/
func (a *ChatControllerAPIService) QuitChatUsingPUT(ctx context.Context, chatId string) ApiQuitChatUsingPUTRequest {
	return ApiQuitChatUsingPUTRequest{
		ApiService: a,
		ctx: ctx,
		chatId: chatId,
	}
}

// Execute executes the request
//  @return ChatView
// Deprecated
func (a *ChatControllerAPIService) QuitChatUsingPUTExecute(r ApiQuitChatUsingPUTRequest) (*ChatView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChatView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChatControllerAPIService.QuitChatUsingPUT")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/chats/quitchat/{chatId}"
	localVarPath = strings.Replace(localVarPath, "{"+"chatId"+"}", url.PathEscape(parameterValueToString(r.chatId, "chatId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRemoveChatMembershipUsingDELETERequest struct {
	ctx context.Context
	ApiService *ChatControllerAPIService
	membershipId string
}

func (r ApiRemoveChatMembershipUsingDELETERequest) Execute() (*MessagePrototype, *http.Response, error) {
	return r.ApiService.RemoveChatMembershipUsingDELETEExecute(r)
}

/*
RemoveChatMembershipUsingDELETE Removes chat membership

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param membershipId Membership id
 @return ApiRemoveChatMembershipUsingDELETERequest
*/
func (a *ChatControllerAPIService) RemoveChatMembershipUsingDELETE(ctx context.Context, membershipId string) ApiRemoveChatMembershipUsingDELETERequest {
	return ApiRemoveChatMembershipUsingDELETERequest{
		ApiService: a,
		ctx: ctx,
		membershipId: membershipId,
	}
}

// Execute executes the request
//  @return MessagePrototype
func (a *ChatControllerAPIService) RemoveChatMembershipUsingDELETEExecute(r ApiRemoveChatMembershipUsingDELETERequest) (*MessagePrototype, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MessagePrototype
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChatControllerAPIService.RemoveChatMembershipUsingDELETE")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/chatmemberships/{membershipId}"
	localVarPath = strings.Replace(localVarPath, "{"+"membershipId"+"}", url.PathEscape(parameterValueToString(r.membershipId, "membershipId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRemoveFromChatUsingPUTRequest struct {
	ctx context.Context
	ApiService *ChatControllerAPIService
	chatId *string
	userId *string
}

// Chat id
func (r ApiRemoveFromChatUsingPUTRequest) ChatId(chatId string) ApiRemoveFromChatUsingPUTRequest {
	r.chatId = &chatId
	return r
}

// User id
func (r ApiRemoveFromChatUsingPUTRequest) UserId(userId string) ApiRemoveFromChatUsingPUTRequest {
	r.userId = &userId
	return r
}

func (r ApiRemoveFromChatUsingPUTRequest) Execute() (*ChatView, *http.Response, error) {
	return r.ApiService.RemoveFromChatUsingPUTExecute(r)
}

/*
RemoveFromChatUsingPUT Removes user from chat

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiRemoveFromChatUsingPUTRequest

Deprecated
*/
func (a *ChatControllerAPIService) RemoveFromChatUsingPUT(ctx context.Context) ApiRemoveFromChatUsingPUTRequest {
	return ApiRemoveFromChatUsingPUTRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ChatView
// Deprecated
func (a *ChatControllerAPIService) RemoveFromChatUsingPUTExecute(r ApiRemoveFromChatUsingPUTRequest) (*ChatView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ChatView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChatControllerAPIService.RemoveFromChatUsingPUT")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/chats/removeuser"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.chatId == nil {
		return localVarReturnValue, nil, reportError("chatId is required and must be specified")
	}
	if r.userId == nil {
		return localVarReturnValue, nil, reportError("userId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "chatId", r.chatId, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiRemoveMyChatMembershipUsingDELETERequest struct {
	ctx context.Context
	ApiService *ChatControllerAPIService
	chatId string
}

func (r ApiRemoveMyChatMembershipUsingDELETERequest) Execute() (*MessagePrototype, *http.Response, error) {
	return r.ApiService.RemoveMyChatMembershipUsingDELETEExecute(r)
}

/*
RemoveMyChatMembershipUsingDELETE Removes logged in user's chat membership

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param chatId Chat id
 @return ApiRemoveMyChatMembershipUsingDELETERequest
*/
func (a *ChatControllerAPIService) RemoveMyChatMembershipUsingDELETE(ctx context.Context, chatId string) ApiRemoveMyChatMembershipUsingDELETERequest {
	return ApiRemoveMyChatMembershipUsingDELETERequest{
		ApiService: a,
		ctx: ctx,
		chatId: chatId,
	}
}

// Execute executes the request
//  @return MessagePrototype
func (a *ChatControllerAPIService) RemoveMyChatMembershipUsingDELETEExecute(r ApiRemoveMyChatMembershipUsingDELETERequest) (*MessagePrototype, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MessagePrototype
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ChatControllerAPIService.RemoveMyChatMembershipUsingDELETE")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/my/chatmemberships/{chatId}"
	localVarPath = strings.Replace(localVarPath, "{"+"chatId"+"}", url.PathEscape(parameterValueToString(r.chatId, "chatId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
