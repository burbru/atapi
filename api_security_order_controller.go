/*
Api Documentation

Api Documentation

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package atapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// SecurityOrderControllerAPIService SecurityOrderControllerAPI service
type SecurityOrderControllerAPIService service

type ApiAddOrderUsingPOSTRequest struct {
	ctx context.Context
	ApiService *SecurityOrderControllerAPIService
	action *string
	numberOfShares *int64
	owner *string
	securityIdentifier *string
	type_ *string
	checkOrderOnly *bool
	counterparty *string
	goodAfterDate *int64
	goodTillDate *int64
	hourlyChange *string
	price *string
}

// SecurityOrder action
func (r ApiAddOrderUsingPOSTRequest) Action(action string) ApiAddOrderUsingPOSTRequest {
	r.action = &action
	return r
}

// Number of shares
func (r ApiAddOrderUsingPOSTRequest) NumberOfShares(numberOfShares int64) ApiAddOrderUsingPOSTRequest {
	r.numberOfShares = &numberOfShares
	return r
}

// ID of securities account
func (r ApiAddOrderUsingPOSTRequest) Owner(owner string) ApiAddOrderUsingPOSTRequest {
	r.owner = &owner
	return r
}

// Security identifier
func (r ApiAddOrderUsingPOSTRequest) SecurityIdentifier(securityIdentifier string) ApiAddOrderUsingPOSTRequest {
	r.securityIdentifier = &securityIdentifier
	return r
}

// SecurityOrder type
func (r ApiAddOrderUsingPOSTRequest) Type_(type_ string) ApiAddOrderUsingPOSTRequest {
	r.type_ = &type_
	return r
}

// Check Order without execution
func (r ApiAddOrderUsingPOSTRequest) CheckOrderOnly(checkOrderOnly bool) ApiAddOrderUsingPOSTRequest {
	r.checkOrderOnly = &checkOrderOnly
	return r
}

// OTC counterparty&#39;s securities account
func (r ApiAddOrderUsingPOSTRequest) Counterparty(counterparty string) ApiAddOrderUsingPOSTRequest {
	r.counterparty = &counterparty
	return r
}

// Good after date (premium feature)
func (r ApiAddOrderUsingPOSTRequest) GoodAfterDate(goodAfterDate int64) ApiAddOrderUsingPOSTRequest {
	r.goodAfterDate = &goodAfterDate
	return r
}

// Good till date (premium feature)
func (r ApiAddOrderUsingPOSTRequest) GoodTillDate(goodTillDate int64) ApiAddOrderUsingPOSTRequest {
	r.goodTillDate = &goodTillDate
	return r
}

// Hourly change
func (r ApiAddOrderUsingPOSTRequest) HourlyChange(hourlyChange string) ApiAddOrderUsingPOSTRequest {
	r.hourlyChange = &hourlyChange
	return r
}

// Price
func (r ApiAddOrderUsingPOSTRequest) Price(price string) ApiAddOrderUsingPOSTRequest {
	r.price = &price
	return r
}

func (r ApiAddOrderUsingPOSTRequest) Execute() (*SecurityOrder, *http.Response, error) {
	return r.ApiService.AddOrderUsingPOSTExecute(r)
}

/*
AddOrderUsingPOST Adds a new security order

Adds a new order to the order book of the security identified by securityIdentifier. It belongs to the owning securities account. A market order needs no price limit. The id of a security account of a counterparty can be submitted for OTC deals.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAddOrderUsingPOSTRequest
*/
func (a *SecurityOrderControllerAPIService) AddOrderUsingPOST(ctx context.Context) ApiAddOrderUsingPOSTRequest {
	return ApiAddOrderUsingPOSTRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return SecurityOrder
func (a *SecurityOrderControllerAPIService) AddOrderUsingPOSTExecute(r ApiAddOrderUsingPOSTRequest) (*SecurityOrder, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SecurityOrder
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SecurityOrderControllerAPIService.AddOrderUsingPOST")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/securityorders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.action == nil {
		return localVarReturnValue, nil, reportError("action is required and must be specified")
	}
	if r.numberOfShares == nil {
		return localVarReturnValue, nil, reportError("numberOfShares is required and must be specified")
	}
	if r.owner == nil {
		return localVarReturnValue, nil, reportError("owner is required and must be specified")
	}
	if r.securityIdentifier == nil {
		return localVarReturnValue, nil, reportError("securityIdentifier is required and must be specified")
	}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "action", r.action, "")
	if r.checkOrderOnly != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "checkOrderOnly", r.checkOrderOnly, "")
	}
	if r.counterparty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "counterparty", r.counterparty, "")
	}
	if r.goodAfterDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "goodAfterDate", r.goodAfterDate, "")
	}
	if r.goodTillDate != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "goodTillDate", r.goodTillDate, "")
	}
	if r.hourlyChange != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "hourlyChange", r.hourlyChange, "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "numberOfShares", r.numberOfShares, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "owner", r.owner, "")
	if r.price != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "price", r.price, "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "securityIdentifier", r.securityIdentifier, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCheckOrderUsingGETRequest struct {
	ctx context.Context
	ApiService *SecurityOrderControllerAPIService
	action *string
	owner *string
	securityIdentifier *string
	type_ *string
	numberOfShares *int64
	price *string
}

// SecurityOrder action
func (r ApiCheckOrderUsingGETRequest) Action(action string) ApiCheckOrderUsingGETRequest {
	r.action = &action
	return r
}

// ID of securities account
func (r ApiCheckOrderUsingGETRequest) Owner(owner string) ApiCheckOrderUsingGETRequest {
	r.owner = &owner
	return r
}

// Security identifier
func (r ApiCheckOrderUsingGETRequest) SecurityIdentifier(securityIdentifier string) ApiCheckOrderUsingGETRequest {
	r.securityIdentifier = &securityIdentifier
	return r
}

// SecurityOrder type
func (r ApiCheckOrderUsingGETRequest) Type_(type_ string) ApiCheckOrderUsingGETRequest {
	r.type_ = &type_
	return r
}

// Number of shares
func (r ApiCheckOrderUsingGETRequest) NumberOfShares(numberOfShares int64) ApiCheckOrderUsingGETRequest {
	r.numberOfShares = &numberOfShares
	return r
}

// Price
func (r ApiCheckOrderUsingGETRequest) Price(price string) ApiCheckOrderUsingGETRequest {
	r.price = &price
	return r
}

func (r ApiCheckOrderUsingGETRequest) Execute() (*OrderCheck, *http.Response, error) {
	return r.ApiService.CheckOrderUsingGETExecute(r)
}

/*
CheckOrderUsingGET Checks Security Order for Acceptance (DEPRECATED: Use addOrder with checkOrder = true)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCheckOrderUsingGETRequest

Deprecated
*/
func (a *SecurityOrderControllerAPIService) CheckOrderUsingGET(ctx context.Context) ApiCheckOrderUsingGETRequest {
	return ApiCheckOrderUsingGETRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return OrderCheck
// Deprecated
func (a *SecurityOrderControllerAPIService) CheckOrderUsingGETExecute(r ApiCheckOrderUsingGETRequest) (*OrderCheck, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OrderCheck
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SecurityOrderControllerAPIService.CheckOrderUsingGET")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/securityorders/check/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.action == nil {
		return localVarReturnValue, nil, reportError("action is required and must be specified")
	}
	if r.owner == nil {
		return localVarReturnValue, nil, reportError("owner is required and must be specified")
	}
	if r.securityIdentifier == nil {
		return localVarReturnValue, nil, reportError("securityIdentifier is required and must be specified")
	}
	if r.type_ == nil {
		return localVarReturnValue, nil, reportError("type_ is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "action", r.action, "")
	if r.numberOfShares != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "numberOfShares", r.numberOfShares, "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "owner", r.owner, "")
	if r.price != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "price", r.price, "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "securityIdentifier", r.securityIdentifier, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "type", r.type_, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteOrderUsingDELETERequest struct {
	ctx context.Context
	ApiService *SecurityOrderControllerAPIService
	orderId string
}

func (r ApiDeleteOrderUsingDELETERequest) Execute() (*MessagePrototype, *http.Response, error) {
	return r.ApiService.DeleteOrderUsingDELETEExecute(r)
}

/*
DeleteOrderUsingDELETE Deletes a single order

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param orderId SecurityOrder id
 @return ApiDeleteOrderUsingDELETERequest
*/
func (a *SecurityOrderControllerAPIService) DeleteOrderUsingDELETE(ctx context.Context, orderId string) ApiDeleteOrderUsingDELETERequest {
	return ApiDeleteOrderUsingDELETERequest{
		ApiService: a,
		ctx: ctx,
		orderId: orderId,
	}
}

// Execute executes the request
//  @return MessagePrototype
func (a *SecurityOrderControllerAPIService) DeleteOrderUsingDELETEExecute(r ApiDeleteOrderUsingDELETERequest) (*MessagePrototype, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MessagePrototype
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SecurityOrderControllerAPIService.DeleteOrderUsingDELETE")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/securityorders/{orderId}"
	localVarPath = strings.Replace(localVarPath, "{"+"orderId"+"}", url.PathEscape(parameterValueToString(r.orderId, "orderId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteOrdersUsingDELETERequest struct {
	ctx context.Context
	ApiService *SecurityOrderControllerAPIService
	owner *string
	createdBefore *string
}

// ID of securities account
func (r ApiDeleteOrdersUsingDELETERequest) Owner(owner string) ApiDeleteOrdersUsingDELETERequest {
	r.owner = &owner
	return r
}

// Orders created before
func (r ApiDeleteOrdersUsingDELETERequest) CreatedBefore(createdBefore string) ApiDeleteOrdersUsingDELETERequest {
	r.createdBefore = &createdBefore
	return r
}

func (r ApiDeleteOrdersUsingDELETERequest) Execute() (*MessagePrototype, *http.Response, error) {
	return r.ApiService.DeleteOrdersUsingDELETEExecute(r)
}

/*
DeleteOrdersUsingDELETE Deletes all orders

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteOrdersUsingDELETERequest
*/
func (a *SecurityOrderControllerAPIService) DeleteOrdersUsingDELETE(ctx context.Context) ApiDeleteOrdersUsingDELETERequest {
	return ApiDeleteOrdersUsingDELETERequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MessagePrototype
func (a *SecurityOrderControllerAPIService) DeleteOrdersUsingDELETEExecute(r ApiDeleteOrdersUsingDELETERequest) (*MessagePrototype, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MessagePrototype
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SecurityOrderControllerAPIService.DeleteOrdersUsingDELETE")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/securityorders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.owner == nil {
		return localVarReturnValue, nil, reportError("owner is required and must be specified")
	}

	if r.createdBefore != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "createdBefore", r.createdBefore, "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "owner", r.owner, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCounterOtcOrdersUsingGETRequest struct {
	ctx context.Context
	ApiService *SecurityOrderControllerAPIService
	securitiesAccountId string
}

func (r ApiGetCounterOtcOrdersUsingGETRequest) Execute() ([]SecurityOrder, *http.Response, error) {
	return r.ApiService.GetCounterOtcOrdersUsingGETExecute(r)
}

/*
GetCounterOtcOrdersUsingGET Lists unfilled counter otc orders for securities account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param securitiesAccountId Securities account id
 @return ApiGetCounterOtcOrdersUsingGETRequest
*/
func (a *SecurityOrderControllerAPIService) GetCounterOtcOrdersUsingGET(ctx context.Context, securitiesAccountId string) ApiGetCounterOtcOrdersUsingGETRequest {
	return ApiGetCounterOtcOrdersUsingGETRequest{
		ApiService: a,
		ctx: ctx,
		securitiesAccountId: securitiesAccountId,
	}
}

// Execute executes the request
//  @return []SecurityOrder
func (a *SecurityOrderControllerAPIService) GetCounterOtcOrdersUsingGETExecute(r ApiGetCounterOtcOrdersUsingGETRequest) ([]SecurityOrder, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SecurityOrder
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SecurityOrderControllerAPIService.GetCounterOtcOrdersUsingGET")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/securityorders/counterparty/{securitiesAccountId}"
	localVarPath = strings.Replace(localVarPath, "{"+"securitiesAccountId"+"}", url.PathEscape(parameterValueToString(r.securitiesAccountId, "securitiesAccountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOrderUsingGETRequest struct {
	ctx context.Context
	ApiService *SecurityOrderControllerAPIService
	orderId string
}

func (r ApiGetOrderUsingGETRequest) Execute() (*SecurityOrder, *http.Response, error) {
	return r.ApiService.GetOrderUsingGETExecute(r)
}

/*
GetOrderUsingGET Returns a single order

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param orderId SecurityOrder id
 @return ApiGetOrderUsingGETRequest
*/
func (a *SecurityOrderControllerAPIService) GetOrderUsingGET(ctx context.Context, orderId string) ApiGetOrderUsingGETRequest {
	return ApiGetOrderUsingGETRequest{
		ApiService: a,
		ctx: ctx,
		orderId: orderId,
	}
}

// Execute executes the request
//  @return SecurityOrder
func (a *SecurityOrderControllerAPIService) GetOrderUsingGETExecute(r ApiGetOrderUsingGETRequest) (*SecurityOrder, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *SecurityOrder
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SecurityOrderControllerAPIService.GetOrderUsingGET")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/securityorders/{orderId}"
	localVarPath = strings.Replace(localVarPath, "{"+"orderId"+"}", url.PathEscape(parameterValueToString(r.orderId, "orderId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOrderbookUsingGETRequest struct {
	ctx context.Context
	ApiService *SecurityOrderControllerAPIService
	securityIdentifier string
}

func (r ApiGetOrderbookUsingGETRequest) Execute() (*OrderBook, *http.Response, error) {
	return r.ApiService.GetOrderbookUsingGETExecute(r)
}

/*
GetOrderbookUsingGET Returns orderbook of security

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param securityIdentifier Security identifier
 @return ApiGetOrderbookUsingGETRequest
*/
func (a *SecurityOrderControllerAPIService) GetOrderbookUsingGET(ctx context.Context, securityIdentifier string) ApiGetOrderbookUsingGETRequest {
	return ApiGetOrderbookUsingGETRequest{
		ApiService: a,
		ctx: ctx,
		securityIdentifier: securityIdentifier,
	}
}

// Execute executes the request
//  @return OrderBook
func (a *SecurityOrderControllerAPIService) GetOrderbookUsingGETExecute(r ApiGetOrderbookUsingGETRequest) (*OrderBook, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OrderBook
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SecurityOrderControllerAPIService.GetOrderbookUsingGET")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/orderbook/{securityIdentifier}"
	localVarPath = strings.Replace(localVarPath, "{"+"securityIdentifier"+"}", url.PathEscape(parameterValueToString(r.securityIdentifier, "securityIdentifier")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOwnedOrdersUsingGETRequest struct {
	ctx context.Context
	ApiService *SecurityOrderControllerAPIService
	securitiesAccountId string
}

func (r ApiGetOwnedOrdersUsingGETRequest) Execute() ([]SecurityOrder, *http.Response, error) {
	return r.ApiService.GetOwnedOrdersUsingGETExecute(r)
}

/*
GetOwnedOrdersUsingGET Lists unfilled orders owned by securities account

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param securitiesAccountId Securities account id
 @return ApiGetOwnedOrdersUsingGETRequest
*/
func (a *SecurityOrderControllerAPIService) GetOwnedOrdersUsingGET(ctx context.Context, securitiesAccountId string) ApiGetOwnedOrdersUsingGETRequest {
	return ApiGetOwnedOrdersUsingGETRequest{
		ApiService: a,
		ctx: ctx,
		securitiesAccountId: securitiesAccountId,
	}
}

// Execute executes the request
//  @return []SecurityOrder
func (a *SecurityOrderControllerAPIService) GetOwnedOrdersUsingGETExecute(r ApiGetOwnedOrdersUsingGETRequest) ([]SecurityOrder, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  []SecurityOrder
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SecurityOrderControllerAPIService.GetOwnedOrdersUsingGET")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/securityorders/securitiesaccount/{securitiesAccountId}"
	localVarPath = strings.Replace(localVarPath, "{"+"securitiesAccountId"+"}", url.PathEscape(parameterValueToString(r.securitiesAccountId, "securitiesAccountId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOwnedOrdersV2UsingGETRequest struct {
	ctx context.Context
	ApiService *SecurityOrderControllerAPIService
	counterparty *string
	page *int32
	securitiesAccountId *string
	size *int32
	sort *[]string
}

// Counterparty securities account id
func (r ApiGetOwnedOrdersV2UsingGETRequest) Counterparty(counterparty string) ApiGetOwnedOrdersV2UsingGETRequest {
	r.counterparty = &counterparty
	return r
}

// Results page you want to retrieve (0..N)
func (r ApiGetOwnedOrdersV2UsingGETRequest) Page(page int32) ApiGetOwnedOrdersV2UsingGETRequest {
	r.page = &page
	return r
}

// Owning securities account id
func (r ApiGetOwnedOrdersV2UsingGETRequest) SecuritiesAccountId(securitiesAccountId string) ApiGetOwnedOrdersV2UsingGETRequest {
	r.securitiesAccountId = &securitiesAccountId
	return r
}

// Number of records per page
func (r ApiGetOwnedOrdersV2UsingGETRequest) Size(size int32) ApiGetOwnedOrdersV2UsingGETRequest {
	r.size = &size
	return r
}

// Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
func (r ApiGetOwnedOrdersV2UsingGETRequest) Sort(sort []string) ApiGetOwnedOrdersV2UsingGETRequest {
	r.sort = &sort
	return r
}

func (r ApiGetOwnedOrdersV2UsingGETRequest) Execute() (*PageSecurityOrder, *http.Response, error) {
	return r.ApiService.GetOwnedOrdersV2UsingGETExecute(r)
}

/*
GetOwnedOrdersV2UsingGET Lists unfilled orders

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetOwnedOrdersV2UsingGETRequest
*/
func (a *SecurityOrderControllerAPIService) GetOwnedOrdersV2UsingGET(ctx context.Context) ApiGetOwnedOrdersV2UsingGETRequest {
	return ApiGetOwnedOrdersV2UsingGETRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PageSecurityOrder
func (a *SecurityOrderControllerAPIService) GetOwnedOrdersV2UsingGETExecute(r ApiGetOwnedOrdersV2UsingGETRequest) (*PageSecurityOrder, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PageSecurityOrder
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "SecurityOrderControllerAPIService.GetOwnedOrdersV2UsingGET")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/securityorders"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.counterparty != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "counterparty", r.counterparty, "")
	}
	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.securitiesAccountId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "securitiesAccountId", r.securitiesAccountId, "")
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "")
	}
	if r.sort != nil {
		t := *r.sort
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sort", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sort", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
