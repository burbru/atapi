/*
Api Documentation

Api Documentation

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package atapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// UserAccountControllerAPIService UserAccountControllerAPI service
type UserAccountControllerAPIService service

type ApiActivateLicenseUsingPATCHRequest struct {
	ctx context.Context
	ApiService *UserAccountControllerAPIService
	licCode string
}

func (r ApiActivateLicenseUsingPATCHRequest) Execute() (*PremiumLicenseView, *http.Response, error) {
	return r.ApiService.ActivateLicenseUsingPATCHExecute(r)
}

/*
ActivateLicenseUsingPATCH Activates premium license

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param licCode Premium license code
 @return ApiActivateLicenseUsingPATCHRequest
*/
func (a *UserAccountControllerAPIService) ActivateLicenseUsingPATCH(ctx context.Context, licCode string) ApiActivateLicenseUsingPATCHRequest {
	return ApiActivateLicenseUsingPATCHRequest{
		ApiService: a,
		ctx: ctx,
		licCode: licCode,
	}
}

// Execute executes the request
//  @return PremiumLicenseView
func (a *UserAccountControllerAPIService) ActivateLicenseUsingPATCHExecute(r ApiActivateLicenseUsingPATCHRequest) (*PremiumLicenseView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PremiumLicenseView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAccountControllerAPIService.ActivateLicenseUsingPATCH")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/premiumlicenses/{licCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"licCode"+"}", url.PathEscape(parameterValueToString(r.licCode, "licCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiAddLicenseUsingPUTRequest struct {
	ctx context.Context
	ApiService *UserAccountControllerAPIService
	days *int32
	reference *string
	goalId *string
	receiverId *string
	userId *string
}

// Days
func (r ApiAddLicenseUsingPUTRequest) Days(days int32) ApiAddLicenseUsingPUTRequest {
	r.days = &days
	return r
}

// Reference
func (r ApiAddLicenseUsingPUTRequest) Reference(reference string) ApiAddLicenseUsingPUTRequest {
	r.reference = &reference
	return r
}

// Goal ID
func (r ApiAddLicenseUsingPUTRequest) GoalId(goalId string) ApiAddLicenseUsingPUTRequest {
	r.goalId = &goalId
	return r
}

// Receiver ID
func (r ApiAddLicenseUsingPUTRequest) ReceiverId(receiverId string) ApiAddLicenseUsingPUTRequest {
	r.receiverId = &receiverId
	return r
}

// User ID
func (r ApiAddLicenseUsingPUTRequest) UserId(userId string) ApiAddLicenseUsingPUTRequest {
	r.userId = &userId
	return r
}

func (r ApiAddLicenseUsingPUTRequest) Execute() (*PremiumLicenseView, *http.Response, error) {
	return r.ApiService.AddLicenseUsingPUTExecute(r)
}

/*
AddLicenseUsingPUT Add premium license

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiAddLicenseUsingPUTRequest
*/
func (a *UserAccountControllerAPIService) AddLicenseUsingPUT(ctx context.Context) ApiAddLicenseUsingPUTRequest {
	return ApiAddLicenseUsingPUTRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PremiumLicenseView
func (a *UserAccountControllerAPIService) AddLicenseUsingPUTExecute(r ApiAddLicenseUsingPUTRequest) (*PremiumLicenseView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PremiumLicenseView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAccountControllerAPIService.AddLicenseUsingPUT")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/premiumlicenses"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.days == nil {
		return localVarReturnValue, nil, reportError("days is required and must be specified")
	}
	if r.reference == nil {
		return localVarReturnValue, nil, reportError("reference is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "days", r.days, "")
	if r.goalId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "goalId", r.goalId, "")
	}
	if r.receiverId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "receiverId", r.receiverId, "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "reference", r.reference, "")
	if r.userId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "userId", r.userId, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiChangeUserUsingPATCHRequest struct {
	ctx context.Context
	ApiService *UserAccountControllerAPIService
	emailSubscriptionType *string
	emailaddress *string
	password *string
	username *string
}

// Email subscription type
func (r ApiChangeUserUsingPATCHRequest) EmailSubscriptionType(emailSubscriptionType string) ApiChangeUserUsingPATCHRequest {
	r.emailSubscriptionType = &emailSubscriptionType
	return r
}

// Email address
func (r ApiChangeUserUsingPATCHRequest) Emailaddress(emailaddress string) ApiChangeUserUsingPATCHRequest {
	r.emailaddress = &emailaddress
	return r
}

// Password
func (r ApiChangeUserUsingPATCHRequest) Password(password string) ApiChangeUserUsingPATCHRequest {
	r.password = &password
	return r
}

// Username
func (r ApiChangeUserUsingPATCHRequest) Username(username string) ApiChangeUserUsingPATCHRequest {
	r.username = &username
	return r
}

func (r ApiChangeUserUsingPATCHRequest) Execute() (*MessagePrototype, *http.Response, error) {
	return r.ApiService.ChangeUserUsingPATCHExecute(r)
}

/*
ChangeUserUsingPATCH Changes user properties

With email notification

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiChangeUserUsingPATCHRequest
*/
func (a *UserAccountControllerAPIService) ChangeUserUsingPATCH(ctx context.Context) ApiChangeUserUsingPATCHRequest {
	return ApiChangeUserUsingPATCHRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MessagePrototype
func (a *UserAccountControllerAPIService) ChangeUserUsingPATCHExecute(r ApiChangeUserUsingPATCHRequest) (*MessagePrototype, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MessagePrototype
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAccountControllerAPIService.ChangeUserUsingPATCH")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/my/user"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.emailSubscriptionType != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "emailSubscriptionType", r.emailSubscriptionType, "")
	}
	if r.emailaddress != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "emailaddress", r.emailaddress, "")
	}
	if r.password != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "password", r.password, "")
	}
	if r.username != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "username", r.username, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateNewUserUsingPOSTRequest struct {
	ctx context.Context
	ApiService *UserAccountControllerAPIService
	emailAddress *string
	password *string
	username *string
	locale *string
}

// Email address
func (r ApiCreateNewUserUsingPOSTRequest) EmailAddress(emailAddress string) ApiCreateNewUserUsingPOSTRequest {
	r.emailAddress = &emailAddress
	return r
}

// Password
func (r ApiCreateNewUserUsingPOSTRequest) Password(password string) ApiCreateNewUserUsingPOSTRequest {
	r.password = &password
	return r
}

// Username
func (r ApiCreateNewUserUsingPOSTRequest) Username(username string) ApiCreateNewUserUsingPOSTRequest {
	r.username = &username
	return r
}

// Locale
func (r ApiCreateNewUserUsingPOSTRequest) Locale(locale string) ApiCreateNewUserUsingPOSTRequest {
	r.locale = &locale
	return r
}

func (r ApiCreateNewUserUsingPOSTRequest) Execute() (*UserAccountView, *http.Response, error) {
	return r.ApiService.CreateNewUserUsingPOSTExecute(r)
}

/*
CreateNewUserUsingPOST Registers a new user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateNewUserUsingPOSTRequest
*/
func (a *UserAccountControllerAPIService) CreateNewUserUsingPOST(ctx context.Context) ApiCreateNewUserUsingPOSTRequest {
	return ApiCreateNewUserUsingPOSTRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UserAccountView
func (a *UserAccountControllerAPIService) CreateNewUserUsingPOSTExecute(r ApiCreateNewUserUsingPOSTRequest) (*UserAccountView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserAccountView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAccountControllerAPIService.CreateNewUserUsingPOST")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user/register"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.emailAddress == nil {
		return localVarReturnValue, nil, reportError("emailAddress is required and must be specified")
	}
	if r.password == nil {
		return localVarReturnValue, nil, reportError("password is required and must be specified")
	}
	if r.username == nil {
		return localVarReturnValue, nil, reportError("username is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "emailAddress", r.emailAddress, "")
	if r.locale != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "locale", r.locale, "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "password", r.password, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "username", r.username, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCreateScreenshotUsingPUTRequest struct {
	ctx context.Context
	ApiService *UserAccountControllerAPIService
}

func (r ApiCreateScreenshotUsingPUTRequest) Execute() (map[string]interface{}, *http.Response, error) {
	return r.ApiService.CreateScreenshotUsingPUTExecute(r)
}

/*
CreateScreenshotUsingPUT Creates screenshot for given url

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateScreenshotUsingPUTRequest
*/
func (a *UserAccountControllerAPIService) CreateScreenshotUsingPUT(ctx context.Context) ApiCreateScreenshotUsingPUTRequest {
	return ApiCreateScreenshotUsingPUTRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return map[string]interface{}
func (a *UserAccountControllerAPIService) CreateScreenshotUsingPUTExecute(r ApiCreateScreenshotUsingPUTRequest) (map[string]interface{}, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  map[string]interface{}
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAccountControllerAPIService.CreateScreenshotUsingPUT")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/screenshot/**"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteUserUsingDELETERequest struct {
	ctx context.Context
	ApiService *UserAccountControllerAPIService
	deletionToken *string
}

// deletionToken
func (r ApiDeleteUserUsingDELETERequest) DeletionToken(deletionToken string) ApiDeleteUserUsingDELETERequest {
	r.deletionToken = &deletionToken
	return r
}

func (r ApiDeleteUserUsingDELETERequest) Execute() (*MessagePrototype, *http.Response, error) {
	return r.ApiService.DeleteUserUsingDELETEExecute(r)
}

/*
DeleteUserUsingDELETE Removes user with deletion token, sends email link when deletion token is not set

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiDeleteUserUsingDELETERequest
*/
func (a *UserAccountControllerAPIService) DeleteUserUsingDELETE(ctx context.Context) ApiDeleteUserUsingDELETERequest {
	return ApiDeleteUserUsingDELETERequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MessagePrototype
func (a *UserAccountControllerAPIService) DeleteUserUsingDELETEExecute(r ApiDeleteUserUsingDELETERequest) (*MessagePrototype, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MessagePrototype
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAccountControllerAPIService.DeleteUserUsingDELETE")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/my/user"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.deletionToken != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "deletionToken", r.deletionToken, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiFindUserUsingGETRequest struct {
	ctx context.Context
	ApiService *UserAccountControllerAPIService
	namePart string
}

func (r ApiFindUserUsingGETRequest) Execute() (*UsernameView, *http.Response, error) {
	return r.ApiService.FindUserUsingGETExecute(r)
}

/*
FindUserUsingGET Finds users by part of their usernames

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namePart Part of user name
 @return ApiFindUserUsingGETRequest
*/
func (a *UserAccountControllerAPIService) FindUserUsingGET(ctx context.Context, namePart string) ApiFindUserUsingGETRequest {
	return ApiFindUserUsingGETRequest{
		ApiService: a,
		ctx: ctx,
		namePart: namePart,
	}
}

// Execute executes the request
//  @return UsernameView
func (a *UserAccountControllerAPIService) FindUserUsingGETExecute(r ApiFindUserUsingGETRequest) (*UsernameView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UsernameView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAccountControllerAPIService.FindUserUsingGET")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/search/users/{namePart}"
	localVarPath = strings.Replace(localVarPath, "{"+"namePart"+"}", url.PathEscape(parameterValueToString(r.namePart, "namePart")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetJwtTokenUsingPOSTRequest struct {
	ctx context.Context
	ApiService *UserAccountControllerAPIService
	password *string
	username *string
	partnerId *string
}

// Password
func (r ApiGetJwtTokenUsingPOSTRequest) Password(password string) ApiGetJwtTokenUsingPOSTRequest {
	r.password = &password
	return r
}

// Username
func (r ApiGetJwtTokenUsingPOSTRequest) Username(username string) ApiGetJwtTokenUsingPOSTRequest {
	r.username = &username
	return r
}

// Partner ID (optional, can be submitted via X-Authorization too)
func (r ApiGetJwtTokenUsingPOSTRequest) PartnerId(partnerId string) ApiGetJwtTokenUsingPOSTRequest {
	r.partnerId = &partnerId
	return r
}

func (r ApiGetJwtTokenUsingPOSTRequest) Execute() (*MessagePrototype, *http.Response, error) {
	return r.ApiService.GetJwtTokenUsingPOSTExecute(r)
}

/*
GetJwtTokenUsingPOST Returns User's JWT Token

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetJwtTokenUsingPOSTRequest
*/
func (a *UserAccountControllerAPIService) GetJwtTokenUsingPOST(ctx context.Context) ApiGetJwtTokenUsingPOSTRequest {
	return ApiGetJwtTokenUsingPOSTRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MessagePrototype
func (a *UserAccountControllerAPIService) GetJwtTokenUsingPOSTExecute(r ApiGetJwtTokenUsingPOSTRequest) (*MessagePrototype, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MessagePrototype
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAccountControllerAPIService.GetJwtTokenUsingPOST")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user/token/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.password == nil {
		return localVarReturnValue, nil, reportError("password is required and must be specified")
	}
	if r.username == nil {
		return localVarReturnValue, nil, reportError("username is required and must be specified")
	}

	if r.partnerId != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "partnerId", r.partnerId, "")
	}
	parameterAddToHeaderOrQuery(localVarQueryParams, "password", r.password, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "username", r.username, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLastActivityUsingGETRequest struct {
	ctx context.Context
	ApiService *UserAccountControllerAPIService
}

func (r ApiGetLastActivityUsingGETRequest) Execute() (*OnlineTrackingView, *http.Response, error) {
	return r.ApiService.GetLastActivityUsingGETExecute(r)
}

/*
GetLastActivityUsingGET Returns online tracking

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetLastActivityUsingGETRequest
*/
func (a *UserAccountControllerAPIService) GetLastActivityUsingGET(ctx context.Context) ApiGetLastActivityUsingGETRequest {
	return ApiGetLastActivityUsingGETRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return OnlineTrackingView
func (a *UserAccountControllerAPIService) GetLastActivityUsingGETExecute(r ApiGetLastActivityUsingGETRequest) (*OnlineTrackingView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *OnlineTrackingView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAccountControllerAPIService.GetLastActivityUsingGET")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/my/onlinetracking"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLicenseUsingGETRequest struct {
	ctx context.Context
	ApiService *UserAccountControllerAPIService
	licCode string
}

func (r ApiGetLicenseUsingGETRequest) Execute() (*PremiumLicenseView, *http.Response, error) {
	return r.ApiService.GetLicenseUsingGETExecute(r)
}

/*
GetLicenseUsingGET Returns premium license

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param licCode Premium license code
 @return ApiGetLicenseUsingGETRequest
*/
func (a *UserAccountControllerAPIService) GetLicenseUsingGET(ctx context.Context, licCode string) ApiGetLicenseUsingGETRequest {
	return ApiGetLicenseUsingGETRequest{
		ApiService: a,
		ctx: ctx,
		licCode: licCode,
	}
}

// Execute executes the request
//  @return PremiumLicenseView
func (a *UserAccountControllerAPIService) GetLicenseUsingGETExecute(r ApiGetLicenseUsingGETRequest) (*PremiumLicenseView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PremiumLicenseView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAccountControllerAPIService.GetLicenseUsingGET")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/premiumlicenses/{licCode}"
	localVarPath = strings.Replace(localVarPath, "{"+"licCode"+"}", url.PathEscape(parameterValueToString(r.licCode, "licCode")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetLoggedInUserAccountUsingGETRequest struct {
	ctx context.Context
	ApiService *UserAccountControllerAPIService
}

func (r ApiGetLoggedInUserAccountUsingGETRequest) Execute() (*UserAccountView, *http.Response, error) {
	return r.ApiService.GetLoggedInUserAccountUsingGETExecute(r)
}

/*
GetLoggedInUserAccountUsingGET Returns the logged in user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetLoggedInUserAccountUsingGETRequest
*/
func (a *UserAccountControllerAPIService) GetLoggedInUserAccountUsingGET(ctx context.Context) ApiGetLoggedInUserAccountUsingGETRequest {
	return ApiGetLoggedInUserAccountUsingGETRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UserAccountView
func (a *UserAccountControllerAPIService) GetLoggedInUserAccountUsingGETExecute(r ApiGetLoggedInUserAccountUsingGETRequest) (*UserAccountView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserAccountView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAccountControllerAPIService.GetLoggedInUserAccountUsingGET")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/user"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOpenGraphImageForUrlUsingGETRequest struct {
	ctx context.Context
	ApiService *UserAccountControllerAPIService
}

func (r ApiGetOpenGraphImageForUrlUsingGETRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.GetOpenGraphImageForUrlUsingGETExecute(r)
}

/*
GetOpenGraphImageForUrlUsingGET getOpenGraphImageForUrl

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetOpenGraphImageForUrlUsingGETRequest
*/
func (a *UserAccountControllerAPIService) GetOpenGraphImageForUrlUsingGET(ctx context.Context) ApiGetOpenGraphImageForUrlUsingGETRequest {
	return ApiGetOpenGraphImageForUrlUsingGETRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return string
func (a *UserAccountControllerAPIService) GetOpenGraphImageForUrlUsingGETExecute(r ApiGetOpenGraphImageForUrlUsingGETRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAccountControllerAPIService.GetOpenGraphImageForUrlUsingGET")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user/ogimage/**"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"image/png"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetOpenGraphImageUsingGETRequest struct {
	ctx context.Context
	ApiService *UserAccountControllerAPIService
	referer *string
}

// referer
func (r ApiGetOpenGraphImageUsingGETRequest) Referer(referer string) ApiGetOpenGraphImageUsingGETRequest {
	r.referer = &referer
	return r
}

func (r ApiGetOpenGraphImageUsingGETRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.GetOpenGraphImageUsingGETExecute(r)
}

/*
GetOpenGraphImageUsingGET getOpenGraphImage

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetOpenGraphImageUsingGETRequest
*/
func (a *UserAccountControllerAPIService) GetOpenGraphImageUsingGET(ctx context.Context) ApiGetOpenGraphImageUsingGETRequest {
	return ApiGetOpenGraphImageUsingGETRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return string
func (a *UserAccountControllerAPIService) GetOpenGraphImageUsingGETExecute(r ApiGetOpenGraphImageUsingGETRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAccountControllerAPIService.GetOpenGraphImageUsingGET")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user/ogimage"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"image/png"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.referer != nil {
		parameterAddToHeaderOrQuery(localVarHeaderParams, "referer", r.referer, "")
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetReferrerUsingGETRequest struct {
	ctx context.Context
	ApiService *UserAccountControllerAPIService
}

func (r ApiGetReferrerUsingGETRequest) Execute() (*MessagePrototype, *http.Response, error) {
	return r.ApiService.GetReferrerUsingGETExecute(r)
}

/*
GetReferrerUsingGET Gets referrer

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetReferrerUsingGETRequest
*/
func (a *UserAccountControllerAPIService) GetReferrerUsingGET(ctx context.Context) ApiGetReferrerUsingGETRequest {
	return ApiGetReferrerUsingGETRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MessagePrototype
func (a *UserAccountControllerAPIService) GetReferrerUsingGETExecute(r ApiGetReferrerUsingGETRequest) (*MessagePrototype, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MessagePrototype
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAccountControllerAPIService.GetReferrerUsingGET")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/my/referrer"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetScreenshotUsingGETRequest struct {
	ctx context.Context
	ApiService *UserAccountControllerAPIService
	username string
}

func (r ApiGetScreenshotUsingGETRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.GetScreenshotUsingGETExecute(r)
}

/*
GetScreenshotUsingGET Return screenshot for given url

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param username username
 @return ApiGetScreenshotUsingGETRequest
*/
func (a *UserAccountControllerAPIService) GetScreenshotUsingGET(ctx context.Context, username string) ApiGetScreenshotUsingGETRequest {
	return ApiGetScreenshotUsingGETRequest{
		ApiService: a,
		ctx: ctx,
		username: username,
	}
}

// Execute executes the request
//  @return string
func (a *UserAccountControllerAPIService) GetScreenshotUsingGETExecute(r ApiGetScreenshotUsingGETRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAccountControllerAPIService.GetScreenshotUsingGET")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user/screenshot/{username}/**"
	localVarPath = strings.Replace(localVarPath, "{"+"username"+"}", url.PathEscape(parameterValueToString(r.username, "username")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"image/png"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUserAccountByRefIdUsingGETRequest struct {
	ctx context.Context
	ApiService *UserAccountControllerAPIService
	refId string
}

func (r ApiGetUserAccountByRefIdUsingGETRequest) Execute() (*UsernameView, *http.Response, error) {
	return r.ApiService.GetUserAccountByRefIdUsingGETExecute(r)
}

/*
GetUserAccountByRefIdUsingGET Returns user by his/her referral ID 

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param refId Ref ID
 @return ApiGetUserAccountByRefIdUsingGETRequest
*/
func (a *UserAccountControllerAPIService) GetUserAccountByRefIdUsingGET(ctx context.Context, refId string) ApiGetUserAccountByRefIdUsingGETRequest {
	return ApiGetUserAccountByRefIdUsingGETRequest{
		ApiService: a,
		ctx: ctx,
		refId: refId,
	}
}

// Execute executes the request
//  @return UsernameView
func (a *UserAccountControllerAPIService) GetUserAccountByRefIdUsingGETExecute(r ApiGetUserAccountByRefIdUsingGETRequest) (*UsernameView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UsernameView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAccountControllerAPIService.GetUserAccountByRefIdUsingGET")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/users/refId/{refId}"
	localVarPath = strings.Replace(localVarPath, "{"+"refId"+"}", url.PathEscape(parameterValueToString(r.refId, "refId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUserAccountByUsernameUsingGETRequest struct {
	ctx context.Context
	ApiService *UserAccountControllerAPIService
	username string
}

func (r ApiGetUserAccountByUsernameUsingGETRequest) Execute() (*UsernameView, *http.Response, error) {
	return r.ApiService.GetUserAccountByUsernameUsingGETExecute(r)
}

/*
GetUserAccountByUsernameUsingGET Returns user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param username Username
 @return ApiGetUserAccountByUsernameUsingGETRequest
*/
func (a *UserAccountControllerAPIService) GetUserAccountByUsernameUsingGET(ctx context.Context, username string) ApiGetUserAccountByUsernameUsingGETRequest {
	return ApiGetUserAccountByUsernameUsingGETRequest{
		ApiService: a,
		ctx: ctx,
		username: username,
	}
}

// Execute executes the request
//  @return UsernameView
func (a *UserAccountControllerAPIService) GetUserAccountByUsernameUsingGETExecute(r ApiGetUserAccountByUsernameUsingGETRequest) (*UsernameView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UsernameView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAccountControllerAPIService.GetUserAccountByUsernameUsingGET")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/users/username/{username}"
	localVarPath = strings.Replace(localVarPath, "{"+"username"+"}", url.PathEscape(parameterValueToString(r.username, "username")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUserAccountUsingGETRequest struct {
	ctx context.Context
	ApiService *UserAccountControllerAPIService
	userId string
}

func (r ApiGetUserAccountUsingGETRequest) Execute() (*UsernameView, *http.Response, error) {
	return r.ApiService.GetUserAccountUsingGETExecute(r)
}

/*
GetUserAccountUsingGET Returns the user

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param userId User id
 @return ApiGetUserAccountUsingGETRequest
*/
func (a *UserAccountControllerAPIService) GetUserAccountUsingGET(ctx context.Context, userId string) ApiGetUserAccountUsingGETRequest {
	return ApiGetUserAccountUsingGETRequest{
		ApiService: a,
		ctx: ctx,
		userId: userId,
	}
}

// Execute executes the request
//  @return UsernameView
func (a *UserAccountControllerAPIService) GetUserAccountUsingGETExecute(r ApiGetUserAccountUsingGETRequest) (*UsernameView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UsernameView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAccountControllerAPIService.GetUserAccountUsingGET")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/users/{userId}"
	localVarPath = strings.Replace(localVarPath, "{"+"userId"+"}", url.PathEscape(parameterValueToString(r.userId, "userId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUserProfileUsingGETRequest struct {
	ctx context.Context
	ApiService *UserAccountControllerAPIService
	username string
}

func (r ApiGetUserProfileUsingGETRequest) Execute() (*UserProfileView, *http.Response, error) {
	return r.ApiService.GetUserProfileUsingGETExecute(r)
}

/*
GetUserProfileUsingGET Returns user profile

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param username Username
 @return ApiGetUserProfileUsingGETRequest
*/
func (a *UserAccountControllerAPIService) GetUserProfileUsingGET(ctx context.Context, username string) ApiGetUserProfileUsingGETRequest {
	return ApiGetUserProfileUsingGETRequest{
		ApiService: a,
		ctx: ctx,
		username: username,
	}
}

// Execute executes the request
//  @return UserProfileView
func (a *UserAccountControllerAPIService) GetUserProfileUsingGETExecute(r ApiGetUserProfileUsingGETRequest) (*UserProfileView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UserProfileView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAccountControllerAPIService.GetUserProfileUsingGET")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/userprofiles/{username}"
	localVarPath = strings.Replace(localVarPath, "{"+"username"+"}", url.PathEscape(parameterValueToString(r.username, "username")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetUsersUsingGETRequest struct {
	ctx context.Context
	ApiService *UserAccountControllerAPIService
}

func (r ApiGetUsersUsingGETRequest) Execute() (*UsernameView, *http.Response, error) {
	return r.ApiService.GetUsersUsingGETExecute(r)
}

/*
GetUsersUsingGET Lists users

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetUsersUsingGETRequest

Deprecated
*/
func (a *UserAccountControllerAPIService) GetUsersUsingGET(ctx context.Context) ApiGetUsersUsingGETRequest {
	return ApiGetUsersUsingGETRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UsernameView
// Deprecated
func (a *UserAccountControllerAPIService) GetUsersUsingGETExecute(r ApiGetUsersUsingGETRequest) (*UsernameView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UsernameView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAccountControllerAPIService.GetUsersUsingGET")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/users"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListAllPremiumOrderEventsUsingGETRequest struct {
	ctx context.Context
	ApiService *UserAccountControllerAPIService
	page *int32
	size *int32
	sort *[]string
}

// Results page you want to retrieve (0..N)
func (r ApiListAllPremiumOrderEventsUsingGETRequest) Page(page int32) ApiListAllPremiumOrderEventsUsingGETRequest {
	r.page = &page
	return r
}

// Number of records per page
func (r ApiListAllPremiumOrderEventsUsingGETRequest) Size(size int32) ApiListAllPremiumOrderEventsUsingGETRequest {
	r.size = &size
	return r
}

// Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
func (r ApiListAllPremiumOrderEventsUsingGETRequest) Sort(sort []string) ApiListAllPremiumOrderEventsUsingGETRequest {
	r.sort = &sort
	return r
}

func (r ApiListAllPremiumOrderEventsUsingGETRequest) Execute() (*PagePremiumOrderEventView, *http.Response, error) {
	return r.ApiService.ListAllPremiumOrderEventsUsingGETExecute(r)
}

/*
ListAllPremiumOrderEventsUsingGET Lists all logged in user's premium order events

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListAllPremiumOrderEventsUsingGETRequest
*/
func (a *UserAccountControllerAPIService) ListAllPremiumOrderEventsUsingGET(ctx context.Context) ApiListAllPremiumOrderEventsUsingGETRequest {
	return ApiListAllPremiumOrderEventsUsingGETRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return PagePremiumOrderEventView
func (a *UserAccountControllerAPIService) ListAllPremiumOrderEventsUsingGETExecute(r ApiListAllPremiumOrderEventsUsingGETRequest) (*PagePremiumOrderEventView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *PagePremiumOrderEventView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAccountControllerAPIService.ListAllPremiumOrderEventsUsingGET")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/premiumorderevents"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "")
	}
	if r.sort != nil {
		t := *r.sort
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sort", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sort", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListPossibleReferrersUsingGETRequest struct {
	ctx context.Context
	ApiService *UserAccountControllerAPIService
	namePart string
	page *int32
	size *int32
	sort *[]string
}

// Results page you want to retrieve (0..N)
func (r ApiListPossibleReferrersUsingGETRequest) Page(page int32) ApiListPossibleReferrersUsingGETRequest {
	r.page = &page
	return r
}

// Number of records per page
func (r ApiListPossibleReferrersUsingGETRequest) Size(size int32) ApiListPossibleReferrersUsingGETRequest {
	r.size = &size
	return r
}

// Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
func (r ApiListPossibleReferrersUsingGETRequest) Sort(sort []string) ApiListPossibleReferrersUsingGETRequest {
	r.sort = &sort
	return r
}

func (r ApiListPossibleReferrersUsingGETRequest) Execute() (*UsernameView, *http.Response, error) {
	return r.ApiService.ListPossibleReferrersUsingGETExecute(r)
}

/*
ListPossibleReferrersUsingGET Lists all possible referrers

Sorted descending by registrationDate as default

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param namePart Part of user name
 @return ApiListPossibleReferrersUsingGETRequest
*/
func (a *UserAccountControllerAPIService) ListPossibleReferrersUsingGET(ctx context.Context, namePart string) ApiListPossibleReferrersUsingGETRequest {
	return ApiListPossibleReferrersUsingGETRequest{
		ApiService: a,
		ctx: ctx,
		namePart: namePart,
	}
}

// Execute executes the request
//  @return UsernameView
func (a *UserAccountControllerAPIService) ListPossibleReferrersUsingGETExecute(r ApiListPossibleReferrersUsingGETRequest) (*UsernameView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UsernameView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAccountControllerAPIService.ListPossibleReferrersUsingGET")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/my/possibleferrers/{namePart}"
	localVarPath = strings.Replace(localVarPath, "{"+"namePart"+"}", url.PathEscape(parameterValueToString(r.namePart, "namePart")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "")
	}
	if r.sort != nil {
		t := *r.sort
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sort", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sort", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListReferredUsersUsingGETRequest struct {
	ctx context.Context
	ApiService *UserAccountControllerAPIService
	page *int32
	search *string
	size *int32
	sort *[]string
}

// Results page you want to retrieve (0..N)
func (r ApiListReferredUsersUsingGETRequest) Page(page int32) ApiListReferredUsersUsingGETRequest {
	r.page = &page
	return r
}

// Fulltext username search
func (r ApiListReferredUsersUsingGETRequest) Search(search string) ApiListReferredUsersUsingGETRequest {
	r.search = &search
	return r
}

// Number of records per page
func (r ApiListReferredUsersUsingGETRequest) Size(size int32) ApiListReferredUsersUsingGETRequest {
	r.size = &size
	return r
}

// Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
func (r ApiListReferredUsersUsingGETRequest) Sort(sort []string) ApiListReferredUsersUsingGETRequest {
	r.sort = &sort
	return r
}

func (r ApiListReferredUsersUsingGETRequest) Execute() (*UsernameView, *http.Response, error) {
	return r.ApiService.ListReferredUsersUsingGETExecute(r)
}

/*
ListReferredUsersUsingGET Lists all users referred by logged in user

Sorted descending by registrationDate as default

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListReferredUsersUsingGETRequest
*/
func (a *UserAccountControllerAPIService) ListReferredUsersUsingGET(ctx context.Context) ApiListReferredUsersUsingGETRequest {
	return ApiListReferredUsersUsingGETRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UsernameView
func (a *UserAccountControllerAPIService) ListReferredUsersUsingGETExecute(r ApiListReferredUsersUsingGETRequest) (*UsernameView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UsernameView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAccountControllerAPIService.ListReferredUsersUsingGET")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/my/referredusers"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "")
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "")
	}
	if r.sort != nil {
		t := *r.sort
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sort", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sort", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListTeamMembersUsingGETRequest struct {
	ctx context.Context
	ApiService *UserAccountControllerAPIService
}

func (r ApiListTeamMembersUsingGETRequest) Execute() (*UsernameView, *http.Response, error) {
	return r.ApiService.ListTeamMembersUsingGETExecute(r)
}

/*
ListTeamMembersUsingGET Lists all team members

Sorted ascending by team department, team role and id

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListTeamMembersUsingGETRequest
*/
func (a *UserAccountControllerAPIService) ListTeamMembersUsingGET(ctx context.Context) ApiListTeamMembersUsingGETRequest {
	return ApiListTeamMembersUsingGETRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UsernameView
func (a *UserAccountControllerAPIService) ListTeamMembersUsingGETExecute(r ApiListTeamMembersUsingGETRequest) (*UsernameView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UsernameView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAccountControllerAPIService.ListTeamMembersUsingGET")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/teammember"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiListUsersUsingGETRequest struct {
	ctx context.Context
	ApiService *UserAccountControllerAPIService
	page *int32
	search *string
	size *int32
	sort *[]string
}

// Results page you want to retrieve (0..N)
func (r ApiListUsersUsingGETRequest) Page(page int32) ApiListUsersUsingGETRequest {
	r.page = &page
	return r
}

// Fulltext username search
func (r ApiListUsersUsingGETRequest) Search(search string) ApiListUsersUsingGETRequest {
	r.search = &search
	return r
}

// Number of records per page
func (r ApiListUsersUsingGETRequest) Size(size int32) ApiListUsersUsingGETRequest {
	r.size = &size
	return r
}

// Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
func (r ApiListUsersUsingGETRequest) Sort(sort []string) ApiListUsersUsingGETRequest {
	r.sort = &sort
	return r
}

func (r ApiListUsersUsingGETRequest) Execute() (*UsernameView, *http.Response, error) {
	return r.ApiService.ListUsersUsingGETExecute(r)
}

/*
ListUsersUsingGET Lists all users

Sorted descending by registrationDate as default

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiListUsersUsingGETRequest
*/
func (a *UserAccountControllerAPIService) ListUsersUsingGET(ctx context.Context) ApiListUsersUsingGETRequest {
	return ApiListUsersUsingGETRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return UsernameView
func (a *UserAccountControllerAPIService) ListUsersUsingGETExecute(r ApiListUsersUsingGETRequest) (*UsernameView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *UsernameView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAccountControllerAPIService.ListUsersUsingGET")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/users"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.search != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "search", r.search, "")
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "")
	}
	if r.sort != nil {
		t := *r.sort
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sort", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sort", t, "multi")
		}
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPaddleWebhookUsingPOSTRequest struct {
	ctx context.Context
	ApiService *UserAccountControllerAPIService
	paddleSignature *string
	content *string
}

// Paddle-Signature
func (r ApiPaddleWebhookUsingPOSTRequest) PaddleSignature(paddleSignature string) ApiPaddleWebhookUsingPOSTRequest {
	r.paddleSignature = &paddleSignature
	return r
}

// content
func (r ApiPaddleWebhookUsingPOSTRequest) Content(content string) ApiPaddleWebhookUsingPOSTRequest {
	r.content = &content
	return r
}

func (r ApiPaddleWebhookUsingPOSTRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.PaddleWebhookUsingPOSTExecute(r)
}

/*
PaddleWebhookUsingPOST paddleWebhook

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiPaddleWebhookUsingPOSTRequest
*/
func (a *UserAccountControllerAPIService) PaddleWebhookUsingPOST(ctx context.Context) ApiPaddleWebhookUsingPOSTRequest {
	return ApiPaddleWebhookUsingPOSTRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return string
func (a *UserAccountControllerAPIService) PaddleWebhookUsingPOSTExecute(r ApiPaddleWebhookUsingPOSTRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAccountControllerAPIService.PaddleWebhookUsingPOST")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user/paddlewebhook"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.paddleSignature == nil {
		return localVarReturnValue, nil, reportError("paddleSignature is required and must be specified")
	}
	if r.content == nil {
		return localVarReturnValue, nil, reportError("content is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	parameterAddToHeaderOrQuery(localVarHeaderParams, "Paddle-Signature", r.paddleSignature, "")
	// body params
	localVarPostBody = r.content
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiResetPasswordUsingPUTRequest struct {
	ctx context.Context
	ApiService *UserAccountControllerAPIService
	emailaddress *string
}

// Email address
func (r ApiResetPasswordUsingPUTRequest) Emailaddress(emailaddress string) ApiResetPasswordUsingPUTRequest {
	r.emailaddress = &emailaddress
	return r
}

func (r ApiResetPasswordUsingPUTRequest) Execute() (*MessagePrototype, *http.Response, error) {
	return r.ApiService.ResetPasswordUsingPUTExecute(r)
}

/*
ResetPasswordUsingPUT Sends email with new password

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiResetPasswordUsingPUTRequest
*/
func (a *UserAccountControllerAPIService) ResetPasswordUsingPUT(ctx context.Context) ApiResetPasswordUsingPUTRequest {
	return ApiResetPasswordUsingPUTRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return MessagePrototype
func (a *UserAccountControllerAPIService) ResetPasswordUsingPUTExecute(r ApiResetPasswordUsingPUTRequest) (*MessagePrototype, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MessagePrototype
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAccountControllerAPIService.ResetPasswordUsingPUT")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user/passwordreset"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.emailaddress == nil {
		return localVarReturnValue, nil, reportError("emailaddress is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "emailaddress", r.emailaddress, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSetReferrerUsingPATCHRequest struct {
	ctx context.Context
	ApiService *UserAccountControllerAPIService
	refId string
}

func (r ApiSetReferrerUsingPATCHRequest) Execute() (*MessagePrototype, *http.Response, error) {
	return r.ApiService.SetReferrerUsingPATCHExecute(r)
}

/*
SetReferrerUsingPATCH Sets referrer (has to be older than logged in user)

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param refId Referrer ID
 @return ApiSetReferrerUsingPATCHRequest
*/
func (a *UserAccountControllerAPIService) SetReferrerUsingPATCH(ctx context.Context, refId string) ApiSetReferrerUsingPATCHRequest {
	return ApiSetReferrerUsingPATCHRequest{
		ApiService: a,
		ctx: ctx,
		refId: refId,
	}
}

// Execute executes the request
//  @return MessagePrototype
func (a *UserAccountControllerAPIService) SetReferrerUsingPATCHExecute(r ApiSetReferrerUsingPATCHRequest) (*MessagePrototype, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MessagePrototype
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAccountControllerAPIService.SetReferrerUsingPATCH")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/my/referrer/{refId}"
	localVarPath = strings.Replace(localVarPath, "{"+"refId"+"}", url.PathEscape(parameterValueToString(r.refId, "refId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiStripeWebhookUsingPOSTRequest struct {
	ctx context.Context
	ApiService *UserAccountControllerAPIService
	content *string
}

// content
func (r ApiStripeWebhookUsingPOSTRequest) Content(content string) ApiStripeWebhookUsingPOSTRequest {
	r.content = &content
	return r
}

func (r ApiStripeWebhookUsingPOSTRequest) Execute() (string, *http.Response, error) {
	return r.ApiService.StripeWebhookUsingPOSTExecute(r)
}

/*
StripeWebhookUsingPOST stripeWebhook

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiStripeWebhookUsingPOSTRequest
*/
func (a *UserAccountControllerAPIService) StripeWebhookUsingPOST(ctx context.Context) ApiStripeWebhookUsingPOSTRequest {
	return ApiStripeWebhookUsingPOSTRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return string
func (a *UserAccountControllerAPIService) StripeWebhookUsingPOSTExecute(r ApiStripeWebhookUsingPOSTRequest) (string, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  string
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "UserAccountControllerAPIService.StripeWebhookUsingPOST")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/user/stripewebhook"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.content == nil {
		return localVarReturnValue, nil, reportError("content is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	// body params
	localVarPostBody = r.content
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
