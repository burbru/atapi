/*
Api Documentation

Api Documentation

API version: 1.0
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package atapi

import (
	"bytes"
	"context"
	"io"
	"net/http"
	"net/url"
	"strings"
	"reflect"
)


// VotingControllerAPIService VotingControllerAPI service
type VotingControllerAPIService service

type ApiCastAllVotesUsingPOSTRequest struct {
	ctx context.Context
	ApiService *VotingControllerAPIService
	onlyHarmless *bool
	votingType *string
}

// onlyHarmless
func (r ApiCastAllVotesUsingPOSTRequest) OnlyHarmless(onlyHarmless bool) ApiCastAllVotesUsingPOSTRequest {
	r.onlyHarmless = &onlyHarmless
	return r
}

// Voting type
func (r ApiCastAllVotesUsingPOSTRequest) VotingType(votingType string) ApiCastAllVotesUsingPOSTRequest {
	r.votingType = &votingType
	return r
}

func (r ApiCastAllVotesUsingPOSTRequest) Execute() (*AbstractPollView, *http.Response, error) {
	return r.ApiService.CastAllVotesUsingPOSTExecute(r)
}

/*
CastAllVotesUsingPOST Casts a vote

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCastAllVotesUsingPOSTRequest
*/
func (a *VotingControllerAPIService) CastAllVotesUsingPOST(ctx context.Context) ApiCastAllVotesUsingPOSTRequest {
	return ApiCastAllVotesUsingPOSTRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AbstractPollView
func (a *VotingControllerAPIService) CastAllVotesUsingPOSTExecute(r ApiCastAllVotesUsingPOSTRequest) (*AbstractPollView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AbstractPollView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VotingControllerAPIService.CastAllVotesUsingPOST")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/polls"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.onlyHarmless == nil {
		return localVarReturnValue, nil, reportError("onlyHarmless is required and must be specified")
	}
	if r.votingType == nil {
		return localVarReturnValue, nil, reportError("votingType is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "onlyHarmless", r.onlyHarmless, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "votingType", r.votingType, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCastVoteUsingPOSTRequest struct {
	ctx context.Context
	ApiService *VotingControllerAPIService
	pollId string
	voices *int64
	votingType *string
}

// Number of voices
func (r ApiCastVoteUsingPOSTRequest) Voices(voices int64) ApiCastVoteUsingPOSTRequest {
	r.voices = &voices
	return r
}

// Voting type
func (r ApiCastVoteUsingPOSTRequest) VotingType(votingType string) ApiCastVoteUsingPOSTRequest {
	r.votingType = &votingType
	return r
}

func (r ApiCastVoteUsingPOSTRequest) Execute() (*AbstractPollView, *http.Response, error) {
	return r.ApiService.CastVoteUsingPOSTExecute(r)
}

/*
CastVoteUsingPOST Casts a vote

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pollId Poll id
 @return ApiCastVoteUsingPOSTRequest
*/
func (a *VotingControllerAPIService) CastVoteUsingPOST(ctx context.Context, pollId string) ApiCastVoteUsingPOSTRequest {
	return ApiCastVoteUsingPOSTRequest{
		ApiService: a,
		ctx: ctx,
		pollId: pollId,
	}
}

// Execute executes the request
//  @return AbstractPollView
func (a *VotingControllerAPIService) CastVoteUsingPOSTExecute(r ApiCastVoteUsingPOSTRequest) (*AbstractPollView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AbstractPollView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VotingControllerAPIService.CastVoteUsingPOST")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/polls/{pollId}"
	localVarPath = strings.Replace(localVarPath, "{"+"pollId"+"}", url.PathEscape(parameterValueToString(r.pollId, "pollId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.voices == nil {
		return localVarReturnValue, nil, reportError("voices is required and must be specified")
	}
	if r.votingType == nil {
		return localVarReturnValue, nil, reportError("votingType is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "voices", r.voices, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "votingType", r.votingType, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiCastVoteV1UsingPOSTRequest struct {
	ctx context.Context
	ApiService *VotingControllerAPIService
	pollId string
	voices *int64
	votingType *string
}

// Number of voices
func (r ApiCastVoteV1UsingPOSTRequest) Voices(voices int64) ApiCastVoteV1UsingPOSTRequest {
	r.voices = &voices
	return r
}

// Voting type
func (r ApiCastVoteV1UsingPOSTRequest) VotingType(votingType string) ApiCastVoteV1UsingPOSTRequest {
	r.votingType = &votingType
	return r
}

func (r ApiCastVoteV1UsingPOSTRequest) Execute() (*AbstractPollView, *http.Response, error) {
	return r.ApiService.CastVoteV1UsingPOSTExecute(r)
}

/*
CastVoteV1UsingPOST Casts a vote

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pollId Poll id
 @return ApiCastVoteV1UsingPOSTRequest

Deprecated
*/
func (a *VotingControllerAPIService) CastVoteV1UsingPOST(ctx context.Context, pollId string) ApiCastVoteV1UsingPOSTRequest {
	return ApiCastVoteV1UsingPOSTRequest{
		ApiService: a,
		ctx: ctx,
		pollId: pollId,
	}
}

// Execute executes the request
//  @return AbstractPollView
// Deprecated
func (a *VotingControllerAPIService) CastVoteV1UsingPOSTExecute(r ApiCastVoteV1UsingPOSTRequest) (*AbstractPollView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AbstractPollView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VotingControllerAPIService.CastVoteV1UsingPOST")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/polls/{pollId}"
	localVarPath = strings.Replace(localVarPath, "{"+"pollId"+"}", url.PathEscape(parameterValueToString(r.pollId, "pollId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.voices == nil {
		return localVarReturnValue, nil, reportError("voices is required and must be specified")
	}
	if r.votingType == nil {
		return localVarReturnValue, nil, reportError("votingType is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "voices", r.voices, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "votingType", r.votingType, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeletePollUsingDELETERequest struct {
	ctx context.Context
	ApiService *VotingControllerAPIService
	pollId string
}

func (r ApiDeletePollUsingDELETERequest) Execute() (*MessagePrototype, *http.Response, error) {
	return r.ApiService.DeletePollUsingDELETEExecute(r)
}

/*
DeletePollUsingDELETE Deletes poll

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pollId Poll id
 @return ApiDeletePollUsingDELETERequest
*/
func (a *VotingControllerAPIService) DeletePollUsingDELETE(ctx context.Context, pollId string) ApiDeletePollUsingDELETERequest {
	return ApiDeletePollUsingDELETERequest{
		ApiService: a,
		ctx: ctx,
		pollId: pollId,
	}
}

// Execute executes the request
//  @return MessagePrototype
func (a *VotingControllerAPIService) DeletePollUsingDELETEExecute(r ApiDeletePollUsingDELETERequest) (*MessagePrototype, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MessagePrototype
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VotingControllerAPIService.DeletePollUsingDELETE")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/polls/{pollId}"
	localVarPath = strings.Replace(localVarPath, "{"+"pollId"+"}", url.PathEscape(parameterValueToString(r.pollId, "pollId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeletePollV1UsingDELETERequest struct {
	ctx context.Context
	ApiService *VotingControllerAPIService
	pollId string
}

func (r ApiDeletePollV1UsingDELETERequest) Execute() (*MessagePrototype, *http.Response, error) {
	return r.ApiService.DeletePollV1UsingDELETEExecute(r)
}

/*
DeletePollV1UsingDELETE Deletes poll

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pollId Poll id
 @return ApiDeletePollV1UsingDELETERequest

Deprecated
*/
func (a *VotingControllerAPIService) DeletePollV1UsingDELETE(ctx context.Context, pollId string) ApiDeletePollV1UsingDELETERequest {
	return ApiDeletePollV1UsingDELETERequest{
		ApiService: a,
		ctx: ctx,
		pollId: pollId,
	}
}

// Execute executes the request
//  @return MessagePrototype
// Deprecated
func (a *VotingControllerAPIService) DeletePollV1UsingDELETEExecute(r ApiDeletePollV1UsingDELETERequest) (*MessagePrototype, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MessagePrototype
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VotingControllerAPIService.DeletePollV1UsingDELETE")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/polls/{pollId}"
	localVarPath = strings.Replace(localVarPath, "{"+"pollId"+"}", url.PathEscape(parameterValueToString(r.pollId, "pollId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExecuteVoteResultUsingPUTRequest struct {
	ctx context.Context
	ApiService *VotingControllerAPIService
	pollId string
}

func (r ApiExecuteVoteResultUsingPUTRequest) Execute() (*MessagePrototype, *http.Response, error) {
	return r.ApiService.ExecuteVoteResultUsingPUTExecute(r)
}

/*
ExecuteVoteResultUsingPUT Executes poll result

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pollId Poll id
 @return ApiExecuteVoteResultUsingPUTRequest
*/
func (a *VotingControllerAPIService) ExecuteVoteResultUsingPUT(ctx context.Context, pollId string) ApiExecuteVoteResultUsingPUTRequest {
	return ApiExecuteVoteResultUsingPUTRequest{
		ApiService: a,
		ctx: ctx,
		pollId: pollId,
	}
}

// Execute executes the request
//  @return MessagePrototype
func (a *VotingControllerAPIService) ExecuteVoteResultUsingPUTExecute(r ApiExecuteVoteResultUsingPUTRequest) (*MessagePrototype, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MessagePrototype
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VotingControllerAPIService.ExecuteVoteResultUsingPUT")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/polls/{pollId}"
	localVarPath = strings.Replace(localVarPath, "{"+"pollId"+"}", url.PathEscape(parameterValueToString(r.pollId, "pollId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiExecuteVoteResultV1UsingPOSTRequest struct {
	ctx context.Context
	ApiService *VotingControllerAPIService
	pollId string
}

func (r ApiExecuteVoteResultV1UsingPOSTRequest) Execute() (*MessagePrototype, *http.Response, error) {
	return r.ApiService.ExecuteVoteResultV1UsingPOSTExecute(r)
}

/*
ExecuteVoteResultV1UsingPOST Executes poll result

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pollId Poll id
 @return ApiExecuteVoteResultV1UsingPOSTRequest

Deprecated
*/
func (a *VotingControllerAPIService) ExecuteVoteResultV1UsingPOST(ctx context.Context, pollId string) ApiExecuteVoteResultV1UsingPOSTRequest {
	return ApiExecuteVoteResultV1UsingPOSTRequest{
		ApiService: a,
		ctx: ctx,
		pollId: pollId,
	}
}

// Execute executes the request
//  @return MessagePrototype
// Deprecated
func (a *VotingControllerAPIService) ExecuteVoteResultV1UsingPOSTExecute(r ApiExecuteVoteResultV1UsingPOSTRequest) (*MessagePrototype, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *MessagePrototype
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VotingControllerAPIService.ExecuteVoteResultV1UsingPOST")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/polls/execute/{pollId}"
	localVarPath = strings.Replace(localVarPath, "{"+"pollId"+"}", url.PathEscape(parameterValueToString(r.pollId, "pollId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAllPollsUsingGETRequest struct {
	ctx context.Context
	ApiService *VotingControllerAPIService
}

func (r ApiGetAllPollsUsingGETRequest) Execute() (*AbstractPollView, *http.Response, error) {
	return r.ApiService.GetAllPollsUsingGETExecute(r)
}

/*
GetAllPollsUsingGET Returns all polls

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAllPollsUsingGETRequest
*/
func (a *VotingControllerAPIService) GetAllPollsUsingGET(ctx context.Context) ApiGetAllPollsUsingGETRequest {
	return ApiGetAllPollsUsingGETRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AbstractPollView
func (a *VotingControllerAPIService) GetAllPollsUsingGETExecute(r ApiGetAllPollsUsingGETRequest) (*AbstractPollView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AbstractPollView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VotingControllerAPIService.GetAllPollsUsingGET")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/polls"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetCompanyPollsUsingGETRequest struct {
	ctx context.Context
	ApiService *VotingControllerAPIService
	companyId string
}

func (r ApiGetCompanyPollsUsingGETRequest) Execute() (*AbstractPollView, *http.Response, error) {
	return r.ApiService.GetCompanyPollsUsingGETExecute(r)
}

/*
GetCompanyPollsUsingGET Returns company's polls

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param companyId Company id
 @return ApiGetCompanyPollsUsingGETRequest
*/
func (a *VotingControllerAPIService) GetCompanyPollsUsingGET(ctx context.Context, companyId string) ApiGetCompanyPollsUsingGETRequest {
	return ApiGetCompanyPollsUsingGETRequest{
		ApiService: a,
		ctx: ctx,
		companyId: companyId,
	}
}

// Execute executes the request
//  @return AbstractPollView
func (a *VotingControllerAPIService) GetCompanyPollsUsingGETExecute(r ApiGetCompanyPollsUsingGETRequest) (*AbstractPollView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AbstractPollView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VotingControllerAPIService.GetCompanyPollsUsingGET")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/companies/{companyId}/polls"
	localVarPath = strings.Replace(localVarPath, "{"+"companyId"+"}", url.PathEscape(parameterValueToString(r.companyId, "companyId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetMyPollsPagedUsingGETRequest struct {
	ctx context.Context
	ApiService *VotingControllerAPIService
	page *int32
	selfInitiated *bool
	size *int32
	sort *[]string
	votingStatus *string
}

// Results page you want to retrieve (0..N)
func (r ApiGetMyPollsPagedUsingGETRequest) Page(page int32) ApiGetMyPollsPagedUsingGETRequest {
	r.page = &page
	return r
}

// Initiated by logged in user
func (r ApiGetMyPollsPagedUsingGETRequest) SelfInitiated(selfInitiated bool) ApiGetMyPollsPagedUsingGETRequest {
	r.selfInitiated = &selfInitiated
	return r
}

// Number of records per page
func (r ApiGetMyPollsPagedUsingGETRequest) Size(size int32) ApiGetMyPollsPagedUsingGETRequest {
	r.size = &size
	return r
}

// Sorting criteria in the format: property(,asc|desc). Default sort order is ascending. Multiple sort criteria are supported.
func (r ApiGetMyPollsPagedUsingGETRequest) Sort(sort []string) ApiGetMyPollsPagedUsingGETRequest {
	r.sort = &sort
	return r
}

// Status of own voting
func (r ApiGetMyPollsPagedUsingGETRequest) VotingStatus(votingStatus string) ApiGetMyPollsPagedUsingGETRequest {
	r.votingStatus = &votingStatus
	return r
}

func (r ApiGetMyPollsPagedUsingGETRequest) Execute() (*AbstractPollView, *http.Response, error) {
	return r.ApiService.GetMyPollsPagedUsingGETExecute(r)
}

/*
GetMyPollsPagedUsingGET Returns logged in user's polls

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetMyPollsPagedUsingGETRequest
*/
func (a *VotingControllerAPIService) GetMyPollsPagedUsingGET(ctx context.Context) ApiGetMyPollsPagedUsingGETRequest {
	return ApiGetMyPollsPagedUsingGETRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AbstractPollView
func (a *VotingControllerAPIService) GetMyPollsPagedUsingGETExecute(r ApiGetMyPollsPagedUsingGETRequest) (*AbstractPollView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AbstractPollView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VotingControllerAPIService.GetMyPollsPagedUsingGET")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/my/polls"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.page != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "page", r.page, "")
	}
	if r.selfInitiated != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "selfInitiated", r.selfInitiated, "")
	}
	if r.size != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "size", r.size, "")
	}
	if r.sort != nil {
		t := *r.sort
		if reflect.TypeOf(t).Kind() == reflect.Slice {
			s := reflect.ValueOf(t)
			for i := 0; i < s.Len(); i++ {
				parameterAddToHeaderOrQuery(localVarQueryParams, "sort", s.Index(i).Interface(), "multi")
			}
		} else {
			parameterAddToHeaderOrQuery(localVarQueryParams, "sort", t, "multi")
		}
	}
	if r.votingStatus != nil {
		parameterAddToHeaderOrQuery(localVarQueryParams, "votingStatus", r.votingStatus, "")
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPollUsingGETRequest struct {
	ctx context.Context
	ApiService *VotingControllerAPIService
	pollId string
}

func (r ApiGetPollUsingGETRequest) Execute() (*AbstractPollView, *http.Response, error) {
	return r.ApiService.GetPollUsingGETExecute(r)
}

/*
GetPollUsingGET Returns poll

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pollId Poll id
 @return ApiGetPollUsingGETRequest
*/
func (a *VotingControllerAPIService) GetPollUsingGET(ctx context.Context, pollId string) ApiGetPollUsingGETRequest {
	return ApiGetPollUsingGETRequest{
		ApiService: a,
		ctx: ctx,
		pollId: pollId,
	}
}

// Execute executes the request
//  @return AbstractPollView
func (a *VotingControllerAPIService) GetPollUsingGETExecute(r ApiGetPollUsingGETRequest) (*AbstractPollView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AbstractPollView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VotingControllerAPIService.GetPollUsingGET")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/polls/{pollId}"
	localVarPath = strings.Replace(localVarPath, "{"+"pollId"+"}", url.PathEscape(parameterValueToString(r.pollId, "pollId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPollV1UsingGETRequest struct {
	ctx context.Context
	ApiService *VotingControllerAPIService
	pollId string
}

func (r ApiGetPollV1UsingGETRequest) Execute() (*AbstractPollView, *http.Response, error) {
	return r.ApiService.GetPollV1UsingGETExecute(r)
}

/*
GetPollV1UsingGET Returns poll

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param pollId Poll id
 @return ApiGetPollV1UsingGETRequest

Deprecated
*/
func (a *VotingControllerAPIService) GetPollV1UsingGET(ctx context.Context, pollId string) ApiGetPollV1UsingGETRequest {
	return ApiGetPollV1UsingGETRequest{
		ApiService: a,
		ctx: ctx,
		pollId: pollId,
	}
}

// Execute executes the request
//  @return AbstractPollView
// Deprecated
func (a *VotingControllerAPIService) GetPollV1UsingGETExecute(r ApiGetPollV1UsingGETRequest) (*AbstractPollView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AbstractPollView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VotingControllerAPIService.GetPollV1UsingGET")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/polls/{pollId}"
	localVarPath = strings.Replace(localVarPath, "{"+"pollId"+"}", url.PathEscape(parameterValueToString(r.pollId, "pollId")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetPollsV1UsingGETRequest struct {
	ctx context.Context
	ApiService *VotingControllerAPIService
}

func (r ApiGetPollsV1UsingGETRequest) Execute() (*AbstractPollView, *http.Response, error) {
	return r.ApiService.GetPollsV1UsingGETExecute(r)
}

/*
GetPollsV1UsingGET Returns logged in user's initiated polls

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetPollsV1UsingGETRequest

Deprecated
*/
func (a *VotingControllerAPIService) GetPollsV1UsingGET(ctx context.Context) ApiGetPollsV1UsingGETRequest {
	return ApiGetPollsV1UsingGETRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return AbstractPollView
// Deprecated
func (a *VotingControllerAPIService) GetPollsV1UsingGETExecute(r ApiGetPollsV1UsingGETRequest) (*AbstractPollView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *AbstractPollView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VotingControllerAPIService.GetPollsV1UsingGET")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/initiatedpolls/"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInitiateCapitalIncreasePollUsingPOSTRequest struct {
	ctx context.Context
	ApiService *VotingControllerAPIService
	capitalIncreaseType *string
	companyId *string
	minimalCashVolume *string
	price *string
}

// Capital increase type
func (r ApiInitiateCapitalIncreasePollUsingPOSTRequest) CapitalIncreaseType(capitalIncreaseType string) ApiInitiateCapitalIncreasePollUsingPOSTRequest {
	r.capitalIncreaseType = &capitalIncreaseType
	return r
}

// Company id
func (r ApiInitiateCapitalIncreasePollUsingPOSTRequest) CompanyId(companyId string) ApiInitiateCapitalIncreasePollUsingPOSTRequest {
	r.companyId = &companyId
	return r
}

// Minimal cash volume
func (r ApiInitiateCapitalIncreasePollUsingPOSTRequest) MinimalCashVolume(minimalCashVolume string) ApiInitiateCapitalIncreasePollUsingPOSTRequest {
	r.minimalCashVolume = &minimalCashVolume
	return r
}

// Price
func (r ApiInitiateCapitalIncreasePollUsingPOSTRequest) Price(price string) ApiInitiateCapitalIncreasePollUsingPOSTRequest {
	r.price = &price
	return r
}

func (r ApiInitiateCapitalIncreasePollUsingPOSTRequest) Execute() (*CapitalIncreasePollView, *http.Response, error) {
	return r.ApiService.InitiateCapitalIncreasePollUsingPOSTExecute(r)
}

/*
InitiateCapitalIncreasePollUsingPOST Initiate capital increase poll

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiInitiateCapitalIncreasePollUsingPOSTRequest
*/
func (a *VotingControllerAPIService) InitiateCapitalIncreasePollUsingPOST(ctx context.Context) ApiInitiateCapitalIncreasePollUsingPOSTRequest {
	return ApiInitiateCapitalIncreasePollUsingPOSTRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CapitalIncreasePollView
func (a *VotingControllerAPIService) InitiateCapitalIncreasePollUsingPOSTExecute(r ApiInitiateCapitalIncreasePollUsingPOSTRequest) (*CapitalIncreasePollView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CapitalIncreasePollView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VotingControllerAPIService.InitiateCapitalIncreasePollUsingPOST")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/capitalincreasepolls"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.capitalIncreaseType == nil {
		return localVarReturnValue, nil, reportError("capitalIncreaseType is required and must be specified")
	}
	if r.companyId == nil {
		return localVarReturnValue, nil, reportError("companyId is required and must be specified")
	}
	if r.minimalCashVolume == nil {
		return localVarReturnValue, nil, reportError("minimalCashVolume is required and must be specified")
	}
	if r.price == nil {
		return localVarReturnValue, nil, reportError("price is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "capitalIncreaseType", r.capitalIncreaseType, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "companyId", r.companyId, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "minimalCashVolume", r.minimalCashVolume, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "price", r.price, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInitiateCapitalReductionPollUsingPOSTRequest struct {
	ctx context.Context
	ApiService *VotingControllerAPIService
	companyId *string
	numberOfShares *int64
	price *string
}

// Company id
func (r ApiInitiateCapitalReductionPollUsingPOSTRequest) CompanyId(companyId string) ApiInitiateCapitalReductionPollUsingPOSTRequest {
	r.companyId = &companyId
	return r
}

// Number of shares
func (r ApiInitiateCapitalReductionPollUsingPOSTRequest) NumberOfShares(numberOfShares int64) ApiInitiateCapitalReductionPollUsingPOSTRequest {
	r.numberOfShares = &numberOfShares
	return r
}

// Price
func (r ApiInitiateCapitalReductionPollUsingPOSTRequest) Price(price string) ApiInitiateCapitalReductionPollUsingPOSTRequest {
	r.price = &price
	return r
}

func (r ApiInitiateCapitalReductionPollUsingPOSTRequest) Execute() (*CapitalReductionPollView, *http.Response, error) {
	return r.ApiService.InitiateCapitalReductionPollUsingPOSTExecute(r)
}

/*
InitiateCapitalReductionPollUsingPOST Initiate capital reduction poll

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiInitiateCapitalReductionPollUsingPOSTRequest
*/
func (a *VotingControllerAPIService) InitiateCapitalReductionPollUsingPOST(ctx context.Context) ApiInitiateCapitalReductionPollUsingPOSTRequest {
	return ApiInitiateCapitalReductionPollUsingPOSTRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return CapitalReductionPollView
func (a *VotingControllerAPIService) InitiateCapitalReductionPollUsingPOSTExecute(r ApiInitiateCapitalReductionPollUsingPOSTRequest) (*CapitalReductionPollView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *CapitalReductionPollView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VotingControllerAPIService.InitiateCapitalReductionPollUsingPOST")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/capitalreductionpolls"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.companyId == nil {
		return localVarReturnValue, nil, reportError("companyId is required and must be specified")
	}
	if r.numberOfShares == nil {
		return localVarReturnValue, nil, reportError("numberOfShares is required and must be specified")
	}
	if r.price == nil {
		return localVarReturnValue, nil, reportError("price is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "companyId", r.companyId, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "numberOfShares", r.numberOfShares, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "price", r.price, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInitiateCashOutPollUsingPOSTRequest struct {
	ctx context.Context
	ApiService *VotingControllerAPIService
	companyId *string
}

// Company id
func (r ApiInitiateCashOutPollUsingPOSTRequest) CompanyId(companyId string) ApiInitiateCashOutPollUsingPOSTRequest {
	r.companyId = &companyId
	return r
}

func (r ApiInitiateCashOutPollUsingPOSTRequest) Execute() (*ShareholderYesNoPollView, *http.Response, error) {
	return r.ApiService.InitiateCashOutPollUsingPOSTExecute(r)
}

/*
InitiateCashOutPollUsingPOST Initiate cash out poll

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiInitiateCashOutPollUsingPOSTRequest
*/
func (a *VotingControllerAPIService) InitiateCashOutPollUsingPOST(ctx context.Context) ApiInitiateCashOutPollUsingPOSTRequest {
	return ApiInitiateCashOutPollUsingPOSTRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ShareholderYesNoPollView
func (a *VotingControllerAPIService) InitiateCashOutPollUsingPOSTExecute(r ApiInitiateCashOutPollUsingPOSTRequest) (*ShareholderYesNoPollView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ShareholderYesNoPollView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VotingControllerAPIService.InitiateCashOutPollUsingPOST")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/polls/cashout"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.companyId == nil {
		return localVarReturnValue, nil, reportError("companyId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "companyId", r.companyId, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInitiateCashOutPollUsingPOST1Request struct {
	ctx context.Context
	ApiService *VotingControllerAPIService
	companyId *string
}

// Company id
func (r ApiInitiateCashOutPollUsingPOST1Request) CompanyId(companyId string) ApiInitiateCashOutPollUsingPOST1Request {
	r.companyId = &companyId
	return r
}

func (r ApiInitiateCashOutPollUsingPOST1Request) Execute() (*ShareholderYesNoPollView, *http.Response, error) {
	return r.ApiService.InitiateCashOutPollUsingPOST1Execute(r)
}

/*
InitiateCashOutPollUsingPOST1 Initiate cash out poll

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiInitiateCashOutPollUsingPOST1Request
*/
func (a *VotingControllerAPIService) InitiateCashOutPollUsingPOST1(ctx context.Context) ApiInitiateCashOutPollUsingPOST1Request {
	return ApiInitiateCashOutPollUsingPOST1Request{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ShareholderYesNoPollView
func (a *VotingControllerAPIService) InitiateCashOutPollUsingPOST1Execute(r ApiInitiateCashOutPollUsingPOST1Request) (*ShareholderYesNoPollView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ShareholderYesNoPollView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VotingControllerAPIService.InitiateCashOutPollUsingPOST1")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/cashoutpolls"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.companyId == nil {
		return localVarReturnValue, nil, reportError("companyId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "companyId", r.companyId, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInitiateChangeCompanyNamePollUsingPOSTRequest struct {
	ctx context.Context
	ApiService *VotingControllerAPIService
	companyId *string
	newName *string
}

// Company id
func (r ApiInitiateChangeCompanyNamePollUsingPOSTRequest) CompanyId(companyId string) ApiInitiateChangeCompanyNamePollUsingPOSTRequest {
	r.companyId = &companyId
	return r
}

// New Name
func (r ApiInitiateChangeCompanyNamePollUsingPOSTRequest) NewName(newName string) ApiInitiateChangeCompanyNamePollUsingPOSTRequest {
	r.newName = &newName
	return r
}

func (r ApiInitiateChangeCompanyNamePollUsingPOSTRequest) Execute() (*EmployCeoPollView, *http.Response, error) {
	return r.ApiService.InitiateChangeCompanyNamePollUsingPOSTExecute(r)
}

/*
InitiateChangeCompanyNamePollUsingPOST Initiate change company name poll

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiInitiateChangeCompanyNamePollUsingPOSTRequest
*/
func (a *VotingControllerAPIService) InitiateChangeCompanyNamePollUsingPOST(ctx context.Context) ApiInitiateChangeCompanyNamePollUsingPOSTRequest {
	return ApiInitiateChangeCompanyNamePollUsingPOSTRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return EmployCeoPollView
func (a *VotingControllerAPIService) InitiateChangeCompanyNamePollUsingPOSTExecute(r ApiInitiateChangeCompanyNamePollUsingPOSTRequest) (*EmployCeoPollView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EmployCeoPollView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VotingControllerAPIService.InitiateChangeCompanyNamePollUsingPOST")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/changecompanynamepolls"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.companyId == nil {
		return localVarReturnValue, nil, reportError("companyId is required and must be specified")
	}
	if r.newName == nil {
		return localVarReturnValue, nil, reportError("newName is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "companyId", r.companyId, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "newName", r.newName, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInitiateDividendPaymentPollUsingPOSTRequest struct {
	ctx context.Context
	ApiService *VotingControllerAPIService
	companyId *string
	maximalCashVolume *string
}

// Company id
func (r ApiInitiateDividendPaymentPollUsingPOSTRequest) CompanyId(companyId string) ApiInitiateDividendPaymentPollUsingPOSTRequest {
	r.companyId = &companyId
	return r
}

// Maximal cash volume
func (r ApiInitiateDividendPaymentPollUsingPOSTRequest) MaximalCashVolume(maximalCashVolume string) ApiInitiateDividendPaymentPollUsingPOSTRequest {
	r.maximalCashVolume = &maximalCashVolume
	return r
}

func (r ApiInitiateDividendPaymentPollUsingPOSTRequest) Execute() (*DividendPaymentPollView, *http.Response, error) {
	return r.ApiService.InitiateDividendPaymentPollUsingPOSTExecute(r)
}

/*
InitiateDividendPaymentPollUsingPOST Initiate dividend payment poll

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiInitiateDividendPaymentPollUsingPOSTRequest
*/
func (a *VotingControllerAPIService) InitiateDividendPaymentPollUsingPOST(ctx context.Context) ApiInitiateDividendPaymentPollUsingPOSTRequest {
	return ApiInitiateDividendPaymentPollUsingPOSTRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DividendPaymentPollView
func (a *VotingControllerAPIService) InitiateDividendPaymentPollUsingPOSTExecute(r ApiInitiateDividendPaymentPollUsingPOSTRequest) (*DividendPaymentPollView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DividendPaymentPollView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VotingControllerAPIService.InitiateDividendPaymentPollUsingPOST")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/dividendpaymentpolls"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.companyId == nil {
		return localVarReturnValue, nil, reportError("companyId is required and must be specified")
	}
	if r.maximalCashVolume == nil {
		return localVarReturnValue, nil, reportError("maximalCashVolume is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "companyId", r.companyId, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "maximalCashVolume", r.maximalCashVolume, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInitiateEmployCeoPollUsingPOSTRequest struct {
	ctx context.Context
	ApiService *VotingControllerAPIService
	companyId *string
	dailyWage *string
}

// Company id
func (r ApiInitiateEmployCeoPollUsingPOSTRequest) CompanyId(companyId string) ApiInitiateEmployCeoPollUsingPOSTRequest {
	r.companyId = &companyId
	return r
}

// Requested daily wage
func (r ApiInitiateEmployCeoPollUsingPOSTRequest) DailyWage(dailyWage string) ApiInitiateEmployCeoPollUsingPOSTRequest {
	r.dailyWage = &dailyWage
	return r
}

func (r ApiInitiateEmployCeoPollUsingPOSTRequest) Execute() (*EmployCeoPollView, *http.Response, error) {
	return r.ApiService.InitiateEmployCeoPollUsingPOSTExecute(r)
}

/*
InitiateEmployCeoPollUsingPOST Initiate employ CEO poll

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiInitiateEmployCeoPollUsingPOSTRequest
*/
func (a *VotingControllerAPIService) InitiateEmployCeoPollUsingPOST(ctx context.Context) ApiInitiateEmployCeoPollUsingPOSTRequest {
	return ApiInitiateEmployCeoPollUsingPOSTRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return EmployCeoPollView
func (a *VotingControllerAPIService) InitiateEmployCeoPollUsingPOSTExecute(r ApiInitiateEmployCeoPollUsingPOSTRequest) (*EmployCeoPollView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EmployCeoPollView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VotingControllerAPIService.InitiateEmployCeoPollUsingPOST")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/employceopolls"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.companyId == nil {
		return localVarReturnValue, nil, reportError("companyId is required and must be specified")
	}
	if r.dailyWage == nil {
		return localVarReturnValue, nil, reportError("dailyWage is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "companyId", r.companyId, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "dailyWage", r.dailyWage, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInitiateEmployCeoPollV1UsingPOSTRequest struct {
	ctx context.Context
	ApiService *VotingControllerAPIService
	companyId *string
	dailyWage *string
}

// Company id
func (r ApiInitiateEmployCeoPollV1UsingPOSTRequest) CompanyId(companyId string) ApiInitiateEmployCeoPollV1UsingPOSTRequest {
	r.companyId = &companyId
	return r
}

// Requested daily wage
func (r ApiInitiateEmployCeoPollV1UsingPOSTRequest) DailyWage(dailyWage string) ApiInitiateEmployCeoPollV1UsingPOSTRequest {
	r.dailyWage = &dailyWage
	return r
}

func (r ApiInitiateEmployCeoPollV1UsingPOSTRequest) Execute() (*EmployCeoPollView, *http.Response, error) {
	return r.ApiService.InitiateEmployCeoPollV1UsingPOSTExecute(r)
}

/*
InitiateEmployCeoPollV1UsingPOST Initiate employ CEO poll

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiInitiateEmployCeoPollV1UsingPOSTRequest

Deprecated
*/
func (a *VotingControllerAPIService) InitiateEmployCeoPollV1UsingPOST(ctx context.Context) ApiInitiateEmployCeoPollV1UsingPOSTRequest {
	return ApiInitiateEmployCeoPollV1UsingPOSTRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return EmployCeoPollView
// Deprecated
func (a *VotingControllerAPIService) InitiateEmployCeoPollV1UsingPOSTExecute(r ApiInitiateEmployCeoPollV1UsingPOSTRequest) (*EmployCeoPollView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *EmployCeoPollView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VotingControllerAPIService.InitiateEmployCeoPollV1UsingPOST")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/polls/employceo"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.companyId == nil {
		return localVarReturnValue, nil, reportError("companyId is required and must be specified")
	}
	if r.dailyWage == nil {
		return localVarReturnValue, nil, reportError("dailyWage is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "companyId", r.companyId, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "dailyWage", r.dailyWage, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInitiateLiquidationPollUsingPOSTRequest struct {
	ctx context.Context
	ApiService *VotingControllerAPIService
	companyId *string
}

// Company id
func (r ApiInitiateLiquidationPollUsingPOSTRequest) CompanyId(companyId string) ApiInitiateLiquidationPollUsingPOSTRequest {
	r.companyId = &companyId
	return r
}

func (r ApiInitiateLiquidationPollUsingPOSTRequest) Execute() (*ShareholderYesNoPollView, *http.Response, error) {
	return r.ApiService.InitiateLiquidationPollUsingPOSTExecute(r)
}

/*
InitiateLiquidationPollUsingPOST Initiate liquidation poll

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiInitiateLiquidationPollUsingPOSTRequest
*/
func (a *VotingControllerAPIService) InitiateLiquidationPollUsingPOST(ctx context.Context) ApiInitiateLiquidationPollUsingPOSTRequest {
	return ApiInitiateLiquidationPollUsingPOSTRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ShareholderYesNoPollView
func (a *VotingControllerAPIService) InitiateLiquidationPollUsingPOSTExecute(r ApiInitiateLiquidationPollUsingPOSTRequest) (*ShareholderYesNoPollView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ShareholderYesNoPollView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VotingControllerAPIService.InitiateLiquidationPollUsingPOST")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/liquidationpolls"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.companyId == nil {
		return localVarReturnValue, nil, reportError("companyId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "companyId", r.companyId, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInitiateLiquidationPollV1UsingPOSTRequest struct {
	ctx context.Context
	ApiService *VotingControllerAPIService
	companyId *string
}

// Company id
func (r ApiInitiateLiquidationPollV1UsingPOSTRequest) CompanyId(companyId string) ApiInitiateLiquidationPollV1UsingPOSTRequest {
	r.companyId = &companyId
	return r
}

func (r ApiInitiateLiquidationPollV1UsingPOSTRequest) Execute() (*ShareholderYesNoPollView, *http.Response, error) {
	return r.ApiService.InitiateLiquidationPollV1UsingPOSTExecute(r)
}

/*
InitiateLiquidationPollV1UsingPOST Initiate liquidation poll

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiInitiateLiquidationPollV1UsingPOSTRequest

Deprecated
*/
func (a *VotingControllerAPIService) InitiateLiquidationPollV1UsingPOST(ctx context.Context) ApiInitiateLiquidationPollV1UsingPOSTRequest {
	return ApiInitiateLiquidationPollV1UsingPOSTRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ShareholderYesNoPollView
// Deprecated
func (a *VotingControllerAPIService) InitiateLiquidationPollV1UsingPOSTExecute(r ApiInitiateLiquidationPollV1UsingPOSTRequest) (*ShareholderYesNoPollView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ShareholderYesNoPollView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VotingControllerAPIService.InitiateLiquidationPollV1UsingPOST")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/polls/liquidation"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.companyId == nil {
		return localVarReturnValue, nil, reportError("companyId is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "companyId", r.companyId, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiInitiateMergerPollUsingPOSTRequest struct {
	ctx context.Context
	ApiService *VotingControllerAPIService
	acquiringCompanyId *string
	companyId *string
	maximalCashVolume *string
}

// Acquiring company id
func (r ApiInitiateMergerPollUsingPOSTRequest) AcquiringCompanyId(acquiringCompanyId string) ApiInitiateMergerPollUsingPOSTRequest {
	r.acquiringCompanyId = &acquiringCompanyId
	return r
}

// Company id
func (r ApiInitiateMergerPollUsingPOSTRequest) CompanyId(companyId string) ApiInitiateMergerPollUsingPOSTRequest {
	r.companyId = &companyId
	return r
}

// Maximal cash volume
func (r ApiInitiateMergerPollUsingPOSTRequest) MaximalCashVolume(maximalCashVolume string) ApiInitiateMergerPollUsingPOSTRequest {
	r.maximalCashVolume = &maximalCashVolume
	return r
}

func (r ApiInitiateMergerPollUsingPOSTRequest) Execute() (*DividendPaymentPollView, *http.Response, error) {
	return r.ApiService.InitiateMergerPollUsingPOSTExecute(r)
}

/*
InitiateMergerPollUsingPOST Initiate merger poll

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiInitiateMergerPollUsingPOSTRequest
*/
func (a *VotingControllerAPIService) InitiateMergerPollUsingPOST(ctx context.Context) ApiInitiateMergerPollUsingPOSTRequest {
	return ApiInitiateMergerPollUsingPOSTRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return DividendPaymentPollView
func (a *VotingControllerAPIService) InitiateMergerPollUsingPOSTExecute(r ApiInitiateMergerPollUsingPOSTRequest) (*DividendPaymentPollView, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *DividendPaymentPollView
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "VotingControllerAPIService.InitiateMergerPollUsingPOST")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/api/v2/mergerpolls"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.acquiringCompanyId == nil {
		return localVarReturnValue, nil, reportError("acquiringCompanyId is required and must be specified")
	}
	if r.companyId == nil {
		return localVarReturnValue, nil, reportError("companyId is required and must be specified")
	}
	if r.maximalCashVolume == nil {
		return localVarReturnValue, nil, reportError("maximalCashVolume is required and must be specified")
	}

	parameterAddToHeaderOrQuery(localVarQueryParams, "acquiringCompanyId", r.acquiringCompanyId, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "companyId", r.companyId, "")
	parameterAddToHeaderOrQuery(localVarQueryParams, "maximalCashVolume", r.maximalCashVolume, "")
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"*/*"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := io.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = io.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
